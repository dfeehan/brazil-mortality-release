---
title: "Vital registration comparison"
params:
  ## comparison_name - are we comparing to VR to the adjusted VR?
  comparison_name: "vr_comparison"
  #comparison_name: "vr_adj_comparison"
  ## geo_name - are we analyzing at the city, region, or national level?
  geo_name: "city"
  #geo_name: "region"
  #geo_name: "national"
  ## do_12mo: if true, run the sibling 12-month estimates
  #do_12mo: true
  do_12mo: false
output:
  html_document:
    df_print: paged
---

This file makes the comparison between the two survey-based estimates
(sibling and network) and the vital registration data.

It uses parameters to choose whether the comparison is at the state or regional level,
and to choose whether the comparison is to the adjusted or unadjusted vital registration.

For replication, this file is not supposed to be run directly; it is run by another
notebook.

```{r}
options(knitr.duplicate.label = "allow")
```

```{r}
library(tidyverse)
library(geofacet)
#devtools::install_github("dgrtwo/drlib")
library(drlib) # has reorder_within / scale_x_reordered for plots

library(gtable) # for customizing map
library(ggplotify) # for customizing map

library(ggforce) # for paginating faceted output
library(latex2exp)
library(broom)

library(gridExtra)

library(demogR)

library(ggrepel)
library(patchwork)
library(tictoc)
library(glue)

## this has coord_obs_pred, which is helpful for plots
library(tune)

# for calculating moran's I
# (spatial autocorrelation)
library(spdep)

# this has color scale
library(viridis)

# to avoid issues w/ spherical geometry (minor detail in making maps)
# see
# https://gis.stackexchange.com/questions/404385/r-sf-some-edges-are-crossing-in-a-multipolygon-how-to-make-it-valid-when-using
sf_use_s2(FALSE)

# has a helper function for symmetric y axis
# devtools::install_github("stefanedwards/lemon")
# (on 20230613)
library(lemon)

library(here)
```

```{r}
comparison_name <- params$comparison_name 

geo_name <- params$geo_name 
```

```{r}
out_dir <- here('out')
data_dir <- here('data')

vr_dir <- file.path(data_dir, 'vr_prepped')

comp_out_dir0 <- file.path(out_dir, comparison_name)
comp_out_dir <- file.path(comp_out_dir0, geo_name)
dir.create(comp_out_dir0, showWarnings = FALSE)
dir.create(comp_out_dir, showWarnings = FALSE)
```

```{r}
tic(glue::glue("Running comparison for {comparison_name} / {geo_name}"))
```


Some aesthetics for the plots

```{r}
color_sib <- "#FC4E07"
color_net <- "#00AFBB"
color_gs <- "black"

shape_sib <- 0
shape_net <- 5
shape_gs  <- 16

region_pal <- tribble(~ region, ~ color,
                      'NO', 'blue',
                      'NE', 'orange',
                      'CW', 'red',
                      'SE', 'green',
                      'SO', 'purple')

age_scale_color <- scale_color_viridis(discrete=TRUE, direction=-1)
```

# Open up the estimates

Load vital registration reference estimates

```{r}
if(comparison_name == 'vr_comparison') {
  
  if(geo_name == 'city') {
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_asdrs.csv")) %>%
      rename(geo = state_abbrev)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_47q18.csv")) %>%
      rename(geo = state_abbrev)
    
  } else if(geo_name == 'region') {

    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_region_asdrs.csv")) %>%
      rename(geo = region)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_region_47q18.csv")) %>%
      rename(geo = region)
    
  } else if (geo_name == 'national') {
    
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_national_asdrs.csv")) %>%
      mutate(geo = 'national')
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_national_47q18.csv")) %>%
      mutate(geo = 'national')
    
  }
  
} else if (comparison_name == 'vr_adj_comparison') {
  
  if(geo_name == 'city') {
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_asdrs_adj.csv"))  %>%
      rename(geo = state_abbrev)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_47q18_adj.csv")) %>%
      rename(geo = state_abbrev)
    
  } else if (geo_name == 'region') {
  
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_region_asdrs_adj.csv")) %>%
      rename(geo = region)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_region_47q18_adj.csv")) %>%
      rename(geo = region)
    
  } else if (geo_name == 'national') {
    
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_national_asdrs_adj.csv")) %>%
      mutate(geo = 'national')
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_national_47q18_adj.csv")) %>%
      mutate(geo = 'national')
    
  }
}
```

Load sibling estimates

```{r}
if(geo_name == 'city') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_boot.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_boot.csv')) %>%
    rename(geo = state_abbrev)
  
  if(params$do_12mo) {
    
    sib_asdrs_12mo <- read_csv(file.path(out_dir, 
                                         'sib_12mo_design_asdrs.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_probs_12mo <- read_csv(file.path(out_dir, 
                                    'sib_12mo_design_probs.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_asdrs_boot_12mo <- read_csv(file.path(out_dir, 
                                         'sib_12mo_design_asdrs_boot.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_probs_boot_12mo <- read_csv(file.path(out_dir, 
                                              'sib_12mo_design_probs_boot.csv')) %>%
      rename(geo = state_abbrev)
  
  }

} else if (geo_name == 'region') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs_region.csv')) %>%
    rename(geo = region)
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs_region.csv')) %>%
    rename(geo = region)
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_region_boot.csv')) %>%
    rename(geo = region)
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_region_boot.csv')) %>%
    rename(geo = region)
  
} else if (geo_name == 'national') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs_national.csv')) %>%
    mutate(geo = 'national')
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs_national.csv')) %>%
    mutate(geo = 'national')
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_national_boot.csv')) %>%
    mutate(geo = 'national')
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_national_boot.csv')) %>%
    mutate(geo = 'national')
  
}
```

Load network estimates

```{r}
if(geo_name == 'city') {
  
  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs.csv')) %>%
    rename(geo = state_abbrev)
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs.csv')) %>%
    rename(geo = state_abbrev)
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_boot.csv')) %>% 
    mutate(method='net_design') %>%
    rename(geo = state_abbrev)
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_boot.csv')) %>% 
    mutate(method='net_design') %>%
    rename(geo = state_abbrev,
           q.47.18 = q.47.18.mean)
  
} else if (geo_name == 'region') {

  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs_region.csv')) %>%
    rename(geo = region)
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs_region.csv')) %>%
    rename(geo = region)
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_region_boot.csv')) %>%
    mutate(method='net_design') %>%
    rename(geo = region)
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_region_boot.csv')) %>%
    mutate(method='net_design') %>%
    rename(geo = region,
           q.47.18 = q.47.18.mean)

} else if (geo_name == 'national') {
  
  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs_national.csv')) %>%
    mutate(geo = 'national')
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs_national.csv')) %>%
    mutate(geo = 'national')
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_national_boot.csv')) %>%
    mutate(method='net_design') %>%
    mutate(geo = 'national')
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_national_boot.csv')) %>%
    mutate(method='net_design') %>%
    mutate(geo = 'national') %>%
    rename(q.47.18 = q.47.18.mean)
  
}
```

Load estimated VR completeness

```{r}
if(geo_name == 'city') {
  ibge_vr_completeness <- read_csv(file.path(out_dir, 
                                             'vr_completeness_estimates.csv')) %>%
    rename(geo = state_abbrev)
}
```

Load city info

```{r}
city.dat <- read_csv(file.path(data_dir, "cities.csv"))
```



## Assemble the different results in one place

```{r}
est_asdrs <- bind_rows(sib_asdrs,
                       net_asdrs) %>%
  filter(agegp10 != '[65,75)') %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_asdrs_boot <- bind_rows(sib_asdrs_boot,
                            net_asdrs_boot) %>%
  filter(agegp10 != '[65,75)') %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_probs <- bind_rows(sib_probs,
                       net_probs) %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_probs_boot <- bind_rows(sib_probs_boot,
                            net_probs_boot) %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))
```

Assemble 12 mo sib results too

```{r}
if(params$do_12mo) {
  est_asdrs_with12mo <- bind_rows(sib_asdrs,
                         sib_asdrs_12mo %>% mutate(method = 'Sibling12mo'),
                         net_asdrs) %>%
    filter(agegp10 != '[65,75)') %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_asdrs_boot_with12mo <- bind_rows(sib_asdrs_boot,
                              sib_asdrs_boot_12mo %>% mutate(method = 'Sibling12mo'),
                              net_asdrs_boot) %>%
    filter(agegp10 != '[65,75)') %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_probs_with12mo <- bind_rows(sib_probs,
                         sib_probs_12mo %>% mutate(method = 'Sibling12mo'),
                         net_probs) %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_probs_boot_with12mo <- bind_rows(sib_probs_boot,
                              sib_probs_boot_12mo %>% mutate(method = 'Sibling12mo'),
                              net_probs_boot) %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))  
}
```

# Summarize estimates

```{r}
# helper: calculate finite population variance
# of the values in some vector x
fp.var <- function(x) {
  return(mean((x - mean(x))^2))
}

# helper: jackknife variance estimate formula
# see, eg, the Efron book
# if x is a vector of jackknife (leave-one-out)
# variance estimates, this function combines them into
# an overall variance estimate
jack.var <- function(x) {
  P <- length(x)
  return( ((P-1)/P)*sum((x - mean(x))^2))
}
```

## Quantitative summaries

MSE on natural scale

```{r}
calc_errors <- function(df, ci = TRUE) {
  res <- df %>%
    mutate(delta = 1000*(post_mean_asdr - gs_asdr),
           delta2 = delta*delta,
           ## NB: delta_rel is the absolute relative error
           ##     and delta_rel_notabs is the relative error w/out taking absolute value
           delta_rel = abs(delta)/(1000*gs_asdr),
           delta_rel_notabs = delta/(1000*gs_asdr))
  if(ci) {
    res <- res %>%
      mutate(ci_covered = as.numeric(gs_asdr >= post_ci_low_asdr & gs_asdr <= post_ci_high_asdr))
  }
  
  return(res)
}

calc_errors_probs <- function(df, ci = TRUE) {
  res <- df %>%
    mutate(delta = post_mean_q - gs_prob,
           delta2 = delta*delta,
           delta_rel = abs(delta)/gs_prob,
           delta_rel_notabs = delta/gs_prob)
  if(ci) {
  res <- res %>% mutate(ci_covered = as.numeric(gs_prob >= post_ci_low_q & gs_prob <= post_ci_high_q))
  }
  return(res)
}
```

```{r}
comp_asdrs <- est_asdrs %>%
  left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
  calc_errors()

comp_asdrs_boot <- est_asdrs_boot %>%
  left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
  calc_errors(ci=FALSE)


comp_asdrs_wide_boot <- comp_asdrs_boot %>%
  select(-gs_asdr, -post_mean_asdr) %>%
  pivot_wider(names_from=method, values_from=c(delta, delta2, delta_rel, delta_rel_notabs)) %>%
  mutate(delta2.n.minus.s = delta2_Network - delta2_Sibling,
         delta_rel.n.minus.s = delta_rel_Network - delta_rel_Sibling)

comp_probs <- est_probs %>%
  left_join(gs_probs %>% dplyr::rename(gs_prob=q.47.18)) %>%
  calc_errors_probs()

comp_probs_boot <- est_probs_boot %>%
  dplyr::rename(post_mean_q = q.47.18) %>%
  left_join(gs_probs %>% dplyr::rename(gs_prob=q.47.18)) %>%
  calc_errors_probs(ci=FALSE)


comp_probs_wide_boot <- comp_probs_boot %>%
  select(-gs_prob, -post_mean_q, -time.period) %>%
  pivot_wider(names_from=method, values_from=c(delta, delta2, delta_rel, delta_rel_notabs)) %>%
  mutate(delta2.n.minus.s = delta2_Network - delta2_Sibling,
         delta_rel.n.minus.s = delta_rel_Network - delta_rel_Sibling)
```

Errors for 12mo sib ests

```{r}
if(params$do_12mo) {
  
  comp_asdrs_with12mo <- est_asdrs_with12mo %>%
    left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
    calc_errors()
  
  # quick table comparing squared error for net / sib / sib 12mo
  errs_with_12mo <- comp_asdrs_with12mo %>%
    group_by(method) %>%
    summarize(mean_delta2 = mean(delta2),
              mean_delta_rel = mean(delta_rel))
  
  write_csv(errs_with_12mo,
            file.path(comp_out_dir, "avg_errs_with_sib12mo.csv"))
  saveRDS(errs_with_12mo,
            file.path(comp_out_dir, "avg_errs_with_sib12mo.rds"))
  
  errs_with_12mo
}
```

## Plots related to ASDR estimates

### Plot directly comparing estimated ASDRs from two methods

```{r plot-compare-ests}
direct_comp_est_asdrs <- 
  est_asdrs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'agegp10', 'geo'),
                       values_from=c('post_mean_asdr'),
                       names_from=c('method')) 

cur_range <- range(log(direct_comp_est_asdrs$Network),
                   log(direct_comp_est_asdrs$Sibling),
                   finite=TRUE)

alpha.val <- .6

# logged
direct_plot_logged <-  direct_comp_est_asdrs %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Network), 
                 y=log(Sibling),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling death rate est.)") +
  xlab("log(Network death rate est.)") +
  age_scale_color +
  theme_bw()

# NB: this is used in paper
saveRDS(direct_plot_logged, file.path(comp_out_dir, "direct_asdr_logged.rds"))
ggsave(filename=file.path(comp_out_dir, "direct_asdr_logged.pdf"),
       plot=direct_plot_logged,
       height=3.5,
       width=3.5)
direct_plot_logged

```


### Scatter plot with all ASDR estimates compared to VR, panel for each method

```{r}
method_facet_names <- c('Sibling' = 'Sibling Estimates',
                        'Network' = 'Network Estimates')

asdr_point_scatter_df <- est_asdrs %>%
  left_join(gs_asdrs) %>% 
  mutate(method = dplyr::recode(method, !!!method_facet_names))

cur_range <- range(c(asdr_point_scatter_df$post_mean_asdr,
                     asdr_point_scatter_df$asdr),
                   finite = TRUE)

asdr_point_scatter <- asdr_point_scatter_df %>%
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_abline(intercept=0, slope=1) +
  #geom_pointrange(aes(x=asdr, 
  geom_point(aes(x=asdr, 
                      y=post_mean_asdr, 
                      #ymin=post_ci_low_asdr,
                      #ymax=post_ci_high_asdr,
                      color=agegp10,
                      shape=sex),
                  alpha=.5) +
                  #size=rel(rel.point.size),
                  #stroke=point.stroke) +
  xlim(cur_range) + ylim(cur_range) +
  scale_x_log10() + 
  scale_y_log10() +
  facet_grid(~ method) +
  ylab("log(Estimated age-specific death rate)") +
  xlab("log(VR age-specific death rate)") +
  guides(color=guide_legend(title='Age', override.aes=list(alpha=1)),
         shape=guide_legend(title='', override.aes=list(alpha=1))) +
  coord_equal() +
  age_scale_color +
  NULL

# NB: this is used in paper
ggsave(filename=file.path(comp_out_dir, "asdr_point_scatter_log.pdf"),
       plot=asdr_point_scatter,
       height=4,
       width=6)
saveRDS(asdr_point_scatter, 
        file.path(comp_out_dir, "asdr_point_scatter_log.rds"))

asdr_point_scatter
```

### Plot that has a matrix of VR/Sibling/Network ests

```{r splom-sib-net-vr}
direct_comp_all_asdrs_df <- 
  est_asdrs %>%
    bind_rows(gs_asdrs %>% rename(post_mean_asdr=asdr) %>% mutate(method='VR')) %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'agegp10', 'geo'),
                       values_from=c('post_mean_asdr'),
                       names_from=c('method')) 

cur_range <- with(direct_comp_all_asdrs_df,
                  range(log(Sibling),
                        log(Network),
                        log(VR),
                        finite=TRUE))


alpha.val <- 0.6

splom_sn <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Sibling), 
                 y=log(Network),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  xlab("log(Sibling death rate est.)") +
  ylab("log(Network death rate est.)") +
  ggtitle("A") +
  age_scale_color +
  theme_bw() 



splom_vn <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(VR), 
                 y=log(Network),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Network death rate est.)") +
  xlab("log(VR death rate)") +
  ggtitle("B") +
  age_scale_color +
  theme_bw() 

splom_vs <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(VR), 
                 y=log(Sibling),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling death rate est.)") +
  xlab("log(VR death rate)") +
  ggtitle("C") +
  age_scale_color +
  theme_bw() 


splom_all <- splom_sn + 
             splom_vn +
             guide_area() +
             splom_vs + 
  plot_layout(guides='collect', nrow=2, byrow=TRUE)

meta_layout <- "
#cccddd
aeeefff
aeeefff
bggghhh
bggghhh
"

row1_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Network))', 
                                  angle=90,
                                  parse=TRUE) +  theme_void()
row2_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Sibling))', 
                                  angle=90,
                                  parse=TRUE) + theme_void()
col1_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Sibling))',
                                  parse=TRUE) + theme_void()
col2_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(VR))',
                                  parse=TRUE) + theme_void()

plotlist <- list(a=row1_title,
                 b=row2_title,
                 c=col1_title,
                 d=col2_title,
                 e=splom_sn,
                 f=splom_vn,
                 g=guide_area(),
                 h=splom_vs)
  
final_splom <- wrap_plots(
     plotlist,
     guides='collect',
     design=meta_layout,
     widths=c(2,10,10)) & 
  theme(legend.box='horizontal')
  #theme(legend.box='horizontal', legend.position='bottom')

fig_height <-7 
fig_width <- fig_height

saveRDS(final_splom, file.path(comp_out_dir, "splom_asdr.rds"))
ggsave(filename=file.path(comp_out_dir, "splom_asdr.pdf"),
       plot=final_splom,
       height=fig_height,
       width=fig_width)
ggsave(filename=file.path(comp_out_dir, "splom_asdr.png"),
       plot=final_splom,
       height=fig_height,
       width=fig_width)
final_splom

# the network/sib comparison alone
# scale saved figure by this amount
lone_fac <- 0.5
splom_sn_tosave <- splom_sn + ggtitle("")
saveRDS(splom_sn_tosave, file.path(comp_out_dir, "net_vs_sib_asdr.rds"))
ggsave(filename=file.path(comp_out_dir, "net_vs_sib_asdr.pdf"),
       plot=splom_sn_tosave,
       height=fig_height*lone_fac,
       width=fig_width*lone_fac)
ggsave(filename=file.path(comp_out_dir, "net_vs_sib_asdr.png"),
       plot=splom_sn_tosave,
       height=fig_height*lone_fac,
       width=fig_width*lone_fac)
final_splom


```


### Estimates from both sources + VR values by geo, one per page


```{r plot-asdrs-ref, fig.width=3.5, fig.height=10}

rel.point.size <- .3
point.stroke <- .2

asdr_point_plot <- 
  est_asdrs %>%
  left_join(gs_asdrs) %>% 
  group_by(sex, geo) %>%
  # order facets by state difficulty
  mutate(delta = post_mean_asdr - asdr,
         state_difficulty = sum(abs(delta))) %>%
  ungroup() %>%
  mutate(geo = as_factor(geo),
         geo = forcats::fct_reorder(geo, state_difficulty)) %>%
         #geo = drlib::reorder_within(geo, state_difficulty, sex)) %>%
  # end new 
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_pointrange(aes(x=agegp10, 
                      y=post_mean_asdr, 
                      ymin=post_ci_low_asdr,
                      ymax=post_ci_high_asdr,
                      color=method,
                      shape=method),
                  position=position_dodge(width=.5),
                  size=rel(rel.point.size),
                  stroke=point.stroke) +
  geom_point(aes(x=agegp10,
                 y=asdr,
                 color='Vital registration',
                 shape='Vital registration'),
             size=rel(rel.point.size),
             stroke=1) +
  ylab("Age-specific death rate") +
  xlab("") +
  theme(strip.background=element_rect(fill=NA)) +
  guides(color=guide_legend(title='Method', override.aes=list(linetype=c(1,1,0))),
  #guides(color=guide_legend(title='Method'),
         shape=guide_legend(title='Method')) +
  scale_shape_manual(values=c('Sibling'=shape_sib, 'Network'=shape_net, 'Vital registration'=shape_gs))+
  scale_color_manual(values=c('Sibling'=color_sib, 'Network'=color_net, 'Vital registration'=color_gs)) +
  theme(legend.position='bottom',
        legend.direction='horizontal')
   
asdr_point_plot_log_onepage <- asdr_point_plot + 
  facet_grid(geo ~ sex) +
  scale_y_log10()

ggsave(filename=file.path(comp_out_dir, "asdr_pointrange_log.pdf"),
       plot=asdr_point_plot_log_onepage,
       height=10,
       width=3.5)
knitr::plot_crop(file.path(comp_out_dir, "asdr_pointrange_log.pdf"))

asdr_point_plot_log_multipage <- asdr_point_plot + 
  facet_grid_paginate(geo ~ sex, 
                      ncol=3, nrow=3) +
  scale_y_log10()


pdf(file.path(comp_out_dir, "asdr_pointrange_log_multipage.pdf"), onefile = TRUE)
for (i in 1:n_pages(asdr_point_plot_log_multipage)) {
    tmp <- asdr_point_plot_log_multipage + 
    facet_grid_paginate(geo ~ sex, 
                        ncol=3, nrow=3,
                        page=i) +
    scale_y_log10() 
    print(tmp)
}
dev.off()
knitr::plot_crop(file.path(comp_out_dir, "asdr_pointrange_log_multipage.pdf"))

asdr_point_plot_log_onepage
```



### Correlations between different sets of estimates

Summarize relationship between sibling and network probability of death estimates with correlation matrix


```{r}
direct_comp_all_probs_df <- 
  est_probs %>%
    bind_rows(gs_probs %>% rename(post_mean_q = q.47.18) %>% mutate(method='VR')) %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 

cat("\n\nCorrelation between probabilities, not on log scale\n")
# not on log scale
print(
  cor(direct_comp_all_probs_df %>% 
           select(Sibling, Network, VR))
)
```

Summarize relationship between sibling and network death rate estimates with correlation matrix


```{r}

cat("\n\nCorrelation between ASDRs, not on log scale\n")
# not on log scale
print(
  cor(direct_comp_all_asdrs_df %>% 
                select(Sibling, Network, VR))
  )
cat("\n\n")

cat("\n\nCorrelation between log(ASDR)s, log(0) mapped to tiny value:\n")
# log scale, replace log(0) with log(1e-8)
print(cor(direct_comp_all_asdrs_df %>% 
      select(Sibling, Network, VR) %>% 
      mutate(across(everything(),log)) %>%
      mutate(Sibling = ifelse(! is.finite(Sibling), log(1e-8), Sibling))))
cat("\n\n")

cat("\n\nCorrelation between log(ASDR)s, dropping rows where sibling estimates are 0\n")
# log scale, drop rows where sibling ests are 0
print(cor(
  direct_comp_all_asdrs_df %>% 
      select(Sibling, Network, VR) %>% 
      mutate(across(everything(),log)) %>%
      #filter(if_all(everything(), ~ is.finite(.x)))
      filter_all(all_vars(is.finite(.)))  
    ))
```


## Plots related to probability estimates 



```{r}
direct_comp_est_probs <- 
  est_probs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 

cur_range <- range(log(direct_comp_est_probs$Network),
                   log(direct_comp_est_probs$Sibling),
                   finite=TRUE)

```

### Scatter plot comparing estimated probs to VR, one panel per method 

```{r}
method_facet_names <- c('Sibling' = 'Sibling Estimates',
                        'Network' = 'Network Estimates')

prob_point_scatter_df <- est_probs %>%
  left_join(gs_probs %>% select(geo, sex, q.47.18)) %>% 
  mutate(method = dplyr::recode(method, !!!method_facet_names))

cur_range <- range(c(prob_point_scatter_df$post_mean_q,
                     prob_point_scatter_df$q.47.18),
                   finite = TRUE)

prob_point_scatter <- prob_point_scatter_df %>%
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=q.47.18, 
                 y=post_mean_q, 
                 shape=sex),
                 alpha=.5) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  facet_grid(~ method) +
  ylab("Estimated probability of adult death") +
  xlab("VR probability of adult death") +
  guides(shape=guide_legend(title='', override.aes=list(alpha=1))) +
  NULL

# NB: this is used in paper
ggsave(filename=file.path(comp_out_dir, "prob_point_scatter.pdf"),
       plot=prob_point_scatter,
       height=4,
       width=6)
saveRDS(prob_point_scatter, 
        file.path(comp_out_dir, "prob_point_scatter.rds"))

prob_point_scatter
```


```{r plot-compare-ests-probs}
direct_comp_est_probs <- 
  est_probs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 
```


```{r}
cur_range <- range(log(direct_comp_est_probs$Network),
                   log(direct_comp_est_probs$Sibling),
                   finite=TRUE)

alpha.val <- .6 
  
# logged
direct_plot_probs_logged <-  direct_comp_est_probs %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Network), 
                 y=log(Sibling),
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling prob. of death est.)") +
  xlab("log(Network prob. of death est.)") +
  theme_bw()

# NB: this is used in paper
saveRDS(direct_plot_probs_logged, file.path(comp_out_dir, "direct_probs_logged.rds"))
ggsave(filename=file.path(comp_out_dir, "direct_probs_logged.pdf"),
       plot=direct_plot_probs_logged,
       height=3.5,
       width=3.5)
direct_plot_probs_logged

```



TODO - for all of these

-- do we want to switch to JAB estimates of MSEs?
-- what about regional and national analyses?


# Summaries of estimated sampling variation

## Minimum detectable effects

```{r}
##
## se - standard error for difference in two means
mde_onesided <- function(se, alpha=.05, beta=.2) {
  return(se * (qnorm(1-(alpha/2)) - qnorm(beta)))  
}

mde_asdrs <- est_asdrs %>% 
  group_by(method, agegp10, sex, time.period) %>% 
  summarize(mean_se = mean(post_sd_asdr), 
            mean_asdr=mean(post_mean_asdr)) %>% 
  mutate(cv_asdr = mean_se/mean_asdr, 
         ## NB: if two estimates both have std err sigma and are independent
         ##     then their difference will have std err sqrt(2)*sigma
         mde = mde_onesided((sqrt(2)*mean_se))) %>%
  mutate(rel_mde = mde / mean_asdr)

mde_probs <- est_probs %>% 
  group_by(method, sex, time.period) %>% 
  summarize(mean_se = mean(post_sd_q), 
            mean_prob = mean(post_mean_q)) %>% 
  mutate(cv_prob = mean_se/mean_prob, 
         ## NB: if two estimates both have std err sigma and are independent
         ##     then their difference will have std err sqrt(2)*sigma
         mde = mde_onesided(sqrt(2)*(mean_se))) %>%
  mutate(rel_mde = mde / mean_prob)

mde_asdrs
mde_probs
```


## CI width 

CI width for asdrs

```{r}
est_asdrs_ci_width <- est_asdrs %>%
  mutate(ci_width = post_ci_high_asdr - post_ci_low_asdr,
         rel_ci_width = ci_width / post_mean_asdr) %>%
  select(method, geo, agegp10, sex, ci_width, rel_ci_width) %>%
  pivot_wider(values_from = c('ci_width', 'rel_ci_width'),
              names_from = 'method',
              names_glue = "{.value}_{tolower(method)}") %>%
  # don't count cases w/ 0 deaths
  filter(ci_width_sibling != 0, ci_width_network != 0) %>%
  mutate(sib_over_net_ci_width = ci_width_sibling / ci_width_network,
         sib_over_net_rel_ci_width = rel_ci_width_sibling / rel_ci_width_network)
```


CI width for probabilities 

```{r}
est_probs_ci_width <- est_probs %>%
  mutate(ci_width = post_ci_high_q - post_ci_low_q,
         rel_ci_width = ci_width / post_mean_q) %>%
  select(method, geo, sex, ci_width, rel_ci_width) %>%
  pivot_wider(values_from = c('ci_width', 'rel_ci_width'),
              names_from = 'method',
              names_glue = "{.value}_{tolower(method)}") %>%
  # don't count cases w/ 0 deaths
  filter(ci_width_sibling != 0, ci_width_network != 0) %>%
  mutate(sib_over_net_ci_width = ci_width_sibling / ci_width_network,
         sib_over_net_rel_ci_width = rel_ci_width_sibling / rel_ci_width_network)
```

Save a dataframe with the CI properties

```{r}
# NB: this is used

all_ci_widths <-
  bind_rows(est_asdrs_ci_width %>% 
              mutate(qoi = 'asdr'),
            est_probs_ci_width %>% 
              mutate(qoi = 'prob')) %>%
  group_by(qoi) %>%
  summarize(mean_ci_width_sibling = mean(ci_width_sibling),
            mean_ci_width_network = mean(ci_width_network),
            avg_sibci_over_netci = mean(sib_over_net_ci_width),
            pct_over_1 = 100*mean(sib_over_net_ci_width > 1),
            # same quantities for relative CI
            mean_rel_ci_width_sibling = mean(rel_ci_width_sibling),
            mean_rel_ci_width_network = mean(rel_ci_width_network),
            avg_rel_sibci_over_netci = mean(sib_over_net_rel_ci_width),
            pct_rel_over_1 = 100*mean(sib_over_net_rel_ci_width > 1))

saveRDS(all_ci_widths,
        file=file.path(comp_out_dir, "ci_width.rds"))

all_ci_widths
```

# Point estimates of Bias/MSE/Var

These get calculated for each method/city/age/sex

```{r bvm-estimates}
asdr_properties_point_estimates <- comp_asdrs_boot %>%
  group_by(geo, sex, agegp10, method) %>%
  summarize( est_bias = mean(post_mean_asdr) - gs_asdr[1],
             est_mse = mean( (post_mean_asdr - gs_asdr[1])^2 ),
             est_mare = mean( abs(post_mean_asdr - gs_asdr[1])/gs_asdr[1]),
             est_var = fp.var(post_mean_asdr),
             est_mean = mean(post_mean_asdr)) %>%
  mutate(est_rmse = sqrt(est_mse)) %>%
  mutate(qty = 'asdr')

prob_properties_point_estimates <- comp_probs_boot %>%
  group_by(geo, sex, method) %>%
  summarize( est_bias = mean(post_mean_q) - gs_prob[1],
             est_mse = mean( (post_mean_q - gs_prob[1])^2 ),
             est_mare = mean( abs(post_mean_q - gs_prob[1])/gs_prob[1]),
             est_var = fp.var(post_mean_q),
             est_mean = mean(post_mean_q)) %>%
  mutate(est_rmse = sqrt(est_mse)) %>%
  mutate(qty = 'prob')
```

# Use JAB to calculate uncertainty in Bias/Variance/MSE


## Load the cluster counts associated w/ our bootstrap resamples

```{r read-cc-data}
survey_data_dir <- file.path(data_dir, 'survey')

cc_file <- "bootstrap_cc_jab10k.rds"
  
boot.cc <- readRDS(file.path(survey_data_dir, cc_file))
```

```{r}
if (geo_name == 'city') {
  
  boot.cc <- boot.cc %>% mutate(geo = state_abbrev)
  
} else if (geo_name == 'region') {
  # join regions onto boot.cc; call them geo
  boot.cc <- boot.cc %>%
    left_join(city.dat %>% select(state_abbrev, region)) %>%
    mutate(geo = region)
  
} else if (geo_name == 'national') {
  
  boot.cc <- boot.cc %>% mutate(geo = 'national')
  
}
```



*Algorithm*:

> for each city/geographical unit c 
>   for each cluster i from 1 to P_c
>     pick out bootstrap reps that don't include the cluster, B(c,-i)
>     calculate \widehat{\E}[B(c,-i)], the average estimate over B(c,-i)
>     calculate \widehat{\V}[B(c,-i)], the variance of estimates over B(c,-i)
>   calculate variance across the variance estimates (\widehat{\V}[B(c,-1)], \dots, \widehat{V}[B(c,-P_c)])

This takes ~20 seconds on my fancy laptop

```{r jab-indexes}
tic("Getting jackknife after bootstrap (JAB) indexes")
# this creates a list with one entry for each PSU
# that maps the PSU to the bootstrap indices that can be used for
# the hold-one-out jackknife after bootstrap calculation based on that PSU
jab_indexes <- 
  # NB: we assume that the columns are in order
  #  boot_rep_1, boot_rep_2, ...
  boot.cc %>%
  select(starts_with('boot_rep')) %>%
  transpose(.names = boot.cc$cb_code) %>%
  # convert number of times each PSU was included in the bootstrap resample
  # into an indicator with value 
  #  ... 1 if PSU was not included (so can be used in JAB calculation)
  #  ... 0 otherwise
  map(., ~ which(unlist(.x, use.names=FALSE) == 0))

# dataframe with cols
#   state_abbrev / geo
#   cb_code
#   jab_indexes - a list column; the entry is the bootstrap reps to use for JAB calculations
#   n_jab - the number of bootstrap resamples that did not have the PSU (and thus that can be used for JAB calculations)
jab_df <- tibble(
  cb_code = names(jab_indexes),
  jab_indexes = jab_indexes
  ) %>%
  left_join(
    #boot.cc %>% select(state_abbrev, cb_code)
    boot.cc %>% select(geo, cb_code)
  ) %>%
  mutate(n_jab = map_dbl(jab_indexes, ~ length(.x)))
toc()
```


## Calculate the leave-one-PSU-out (LOPO) estimates 

This takes about 8.5 minutes on my fancy laptop...

```{r leave-one-psu-out-estimates}
tic("Calculating leave-one PSU out estimates to use with jackknife after bootstrap")
lopo_ests <- jab_df %>%
  mutate(
    # leave one psu out ests
    lopo_ests = map2(jab_indexes, 
                     geo,
                     # this function takes a list of bootstrap indexes and
                     # calculates summaries of all of the estimates based
                     # on those indexes
                     function(jab_boot_indexes, cur_geo) {
                        cur_res <- comp_asdrs_boot %>%
                          filter(geo == cur_geo) %>%
                          # filter to boot indexes to be used for the hold-one-out calculations
                          # based on this index
                          filter(boot_idx %in% jab_boot_indexes) %>%
                          group_by(geo,sex,agegp10,method) %>%
                          summarize(n_jab_check = n(),
                                    # fp.var is our custom function that has n in the denom instead of (n-1)
                                    var_asdr_lopo = fp.var(post_mean_asdr),
                                    mean_asdr_lopo = mean(post_mean_asdr),
                                    bias_asdr_lopo = mean(post_mean_asdr - gs_asdr),
                                    mse_asdr_lopo = mean((post_mean_asdr - gs_asdr)^2),
                                    mare_asdr_lopo = mean( abs(post_mean_asdr - gs_asdr) / gs_asdr),
                                    .groups = "drop") %>%
                          mutate(rmse_asdr_lopo = sqrt(mse_asdr_lopo))
                        
                        return(cur_res)
                       
                     }))
toc()

tic("Calculating leave-one PSU out estimates of probabilities to use with jackknife after bootstrap")
lopo_prob_ests <- jab_df %>%
  mutate(
    # leave one psu out ests
    lopo_ests = map2(jab_indexes, 
                     geo,
                     # this function takes a list of bootstrap indexes and
                     # calculates summaries of all of the estimates based
                     # on those indexes
                     function(jab_boot_indexes, cur_geo) {
                        cur_res <- comp_probs_boot %>%
                          filter(geo == cur_geo) %>%
                          # filter to boot indexes to be used for the hold-one-out calculations
                          # based on this index
                          filter(boot_idx %in% jab_boot_indexes) %>%
                          group_by(geo,sex,method) %>%
                          summarize(n_jab_check = n(),
                                    # fp.var is our custom function that has n in the denom instead of (n-1)
                                    var_prob_lopo = fp.var(post_mean_q),
                                    mean_prob_lopo = mean(post_mean_q),
                                    bias_prob_lopo = mean(post_mean_q - gs_prob),
                                    mse_prob_lopo = mean((post_mean_q - gs_prob)^2),
                                    mare_prob_lopo = mean( abs(post_mean_q - gs_prob) / gs_prob),
                                    .groups = "drop") %>%
                          mutate(rmse_prob_lopo = sqrt(mse_prob_lopo))
                          
                        return(cur_res)
                       
                     }))
toc()
```

And wide version to calculate LOPO estimates for differences

```{r}
# this produces a tibble with one row for each
# PSU x age-sex group (so, 10 times the number of PSUs, \approx 41,000)
# note that, since each PSU is in exactly one city, each row here is
# a LOPO estimate that corresponds to a city/age/sex cell
lopo_ests_wide <- lopo_ests %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  select(-geo) %>%
  unnest(lopo_ests) %>%
  pivot_wider(names_from = 'method',
              values_from = c('rmse_asdr_lopo', 'mare_asdr_lopo',
                              'mse_asdr_lopo', 'bias_asdr_lopo',
                              'mean_asdr_lopo', 'var_asdr_lopo'),
              id_cols=c('cb_code', 'geo', 'agegp10', 'sex')) %>%
  pivot_longer(cols = contains('_lopo_'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*_lopo)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  mutate(qty = 'asdr')
```

```{r}
lopo_prob_ests_wide <- lopo_prob_ests %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  select(-geo) %>%
  unnest(lopo_ests) %>%
  pivot_wider(names_from = 'method',
              values_from = matches('prob_lopo'),
              id_cols=c('cb_code', 'geo', 'sex')) %>%
  pivot_longer(cols = contains('_lopo_'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*_lopo)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  mutate(qty = 'prob')
```

## Calculate properties of estimators at different levels of aggregation

### Age/Sex/Geo level

#### ASDRs

Use jackknife after bootstrap to estimate the properties of estimated death rate for each city/age/sex/method

```{r jab-estimates}
jab_asdr_ests <- lopo_ests_wide %>%
  #select(-jab_indexes) %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  #group_by(state_abbrev, geo, sex, agegp10, method) %>%
  group_by(geo, sex, agegp10) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  ungroup() %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}"))
```

```{r}
asdr_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_asdr_ests)
```


#### Probabilities

... and repeat for probabilities, one for each city/sex/method

```{r jab-estimates}
jab_prob_ests <- lopo_prob_ests_wide %>%
  #select(-jab_indexes) %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  #group_by(state_abbrev, geo, sex, agegp10, method) %>%
  group_by(geo, sex) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}"))
```

```{r}
prob_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_prob_ests)
```

### Geo level

#### ASDRs

```{r}
jab_geo_asdr_ests <- lopo_ests_wide %>%
  # aggregate LOPO estimates across age/sex groups within this city and PSU
  group_by(geo, cb_code) %>%
  summarize(# number of age/sex groups aggregated over (for debugging) 
            n_agesex_gps = n(),
            across(matches("^mean|^mse_|^rmse_|^bias_|^var_"),
                   mean,
                   # don't change the name of each column...
                   .names = "{.col}")) %>%
  group_by(geo) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```


```{r}
asdr_geo_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(geo, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_geo_asdr_ests)
```

#### Probabilities

```{r}
jab_geo_prob_ests <- lopo_prob_ests_wide %>%
  # aggregate LOPO estimates across age/sex groups within this city and PSU
  group_by(geo, cb_code) %>%
  summarize(# number of age/sex groups aggregated over (for debugging) 
            n_agesex_gps = n(),
            across(matches("^mean|^mse_|^rmse_|^bias_|^var_"),
                   mean,
                   # don't change the name of each column...
                   .names = "{.col}")) %>%
  group_by(geo) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'prob')
```

```{r}
prob_geo_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(geo, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_geo_prob_ests)
```


### Age/sex level

#### ASDRs

TODO - THINK ABOUT THIS
when aggregating up to an age across cities, need the (1/27)^2
when just calculating a mean, we do not need that

I think for each LOPO

```{r}
if (geo_name == 'city') {
  NUM_GEO_UNITS <- 27
} else if (geo_name == 'region') {
  NUM_GEO_UNITS <- 5
} else if (geo_name == 'national') {
  NUM_GEO_UNITS <- 1
}
  #summarize(across(starts_with('var'), 
  #                 ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
  #                 .names = "{.col}")) %>%
    
jab_agesex_asdr_ests <- jab_asdr_ests %>%
  group_by(agegp10, sex) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                           mean,
                           .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```


```{r}
asdr_agesex_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to age/sex level (by averaging across cities)
  group_by(agegp10, sex, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_agesex_asdr_ests) 
  # TODO - ADD SE?
```

#### NB: Probs not applicable 

N/A

### Total level 

#### ASDRs

```{r}
jab_tot_asdr_ests <- jab_geo_asdr_ests %>%
  group_by(1) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                   mean,
                   .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```

```{r}
asdr_tot_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  bind_cols(jab_tot_asdr_ests)
  # TODO - ADD SE?
```


#### Probs


```{r}
jab_tot_prob_ests <- jab_geo_prob_ests %>%
  group_by(1) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                   mean,
                   .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'prob')
```

```{r}
prob_tot_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  bind_cols(jab_tot_prob_ests)
```


LEFT OFF HERE: I think the results we need are in

- asdr_properties
- asdr_geo_properties
- asdr_agesex_properties
- asdr_tot_properties

and

- prob_properties
- prob_geo_properties
- prob_tot_properties

NEXT STEPS

- fix plots below here to use these new versions
- save these to a file
- go into 06_plots.Rmd and have it use these new files


# CHANGING ABOVE HERE

### Calculate JAB-based uncertainty in estimated difference in RMSE and probs

#### Get JAB uncertainty estimates in ASDR error differences within geo/age/sex group

For the individual methods

```{r}

# use JAB to calculate
# uncertainty in estimated difference in RMSE between the two methods in each city,
# aggregating across age/sex groups
jab_asdr_diff_ests <- lopo_ests_wide %>%
  # this renaming is just for convenience
  # (below, when we aggregate up to city, we do something else here)
  mutate(mean_rmse_asdr_lopo_n_minus_s = rmse_asdr_lopo_n_minus_s,
         mean_mare_asdr_lopo_n_minus_s = mare_asdr_lopo_n_minus_s) %>%
  # and now take the LOPO estimates for 
  # each city/age/sex/PSU, and aggregate these using the jackknife formula
  # this produces an estimated variance of the estimated RMSE difference 
  # within each city
  group_by(geo, sex, agegp10) %>%
  # estimated variance in city MSE difference estimate, using JAB
  summarize(# aggregate across the LOPO values with the jackknife variance formula
            var_rmse_n_minus_s_jab = jack.var(mean_rmse_asdr_lopo_n_minus_s),
            var_mare_n_minus_s_jab = jack.var(mean_mare_asdr_lopo_n_minus_s),
            # and this is the mean difference across LOPO values
            mean_rmse_lopo_n_minus_s_jab = mean(mean_rmse_asdr_lopo_n_minus_s),
            mean_mare_lopo_n_minus_s_jab = mean(mean_mare_asdr_lopo_n_minus_s),
            .groups='drop') %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab)) %>%
  mutate(qty = 'asdr')

## TODO - add JAB estimates for individual methods to jab_asdr_diff_ests
```

#### Get JAB uncertainty estimates in ASDR error differences at geo level

```{r}
# use JAB to calculate
# uncertainty in estimated difference in RMSE between the two methods in each city,
# aggregating across age/sex groups
jab_geo_diff_ests <- lopo_ests_wide %>%
  ## now use the jackknife formula to get variance estimates for each city
  group_split(geo) %>%
  map_dfr(~ {
    .x %>%
      # aggregate LOPO estimates across age/sex groups within this city and PSU
      group_by(geo, cb_code) %>%
      summarize(
                 mean_rmse_asdr_lopo_n_minus_s = mean(rmse_asdr_lopo_n_minus_s),
                 mean_mare_asdr_lopo_n_minus_s = mean(mare_asdr_lopo_n_minus_s),
                 mean_rmse_asdr_lopo_Sibling = mean(rmse_asdr_lopo_Sibling),
                 mean_rmse_asdr_lopo_Network = mean(rmse_asdr_lopo_Network),
                 mean_mare_asdr_lopo_Sibling = mean(mare_asdr_lopo_Sibling),
                 mean_mare_asdr_lopo_Network = mean(mare_asdr_lopo_Network),
                .groups='drop')
                # this should be 10 (since there are 10 age/sex groups)
                #num_gp_check = n())
  }) %>%
  # and now take the aggregated (across age/sex) LOPO estimates for 
  # each city/PSU, and aggregate these using the jackknife formula
  # this produces an estimated variance of the estimated RMSE difference 
  # within each city
  group_by(geo) %>%
  # estimated variance in city MSE difference estimate, using JAB
  summarize(# aggregate across the LOPO values with the jackknife variance formula
            var_rmse_n_minus_s_jab = jack.var(mean_rmse_asdr_lopo_n_minus_s),
            var_mare_n_minus_s_jab = jack.var(mean_mare_asdr_lopo_n_minus_s),
            var_rmse_Network = jack.var(mean_rmse_asdr_lopo_Network),
            var_rmse_Sibling = jack.var(mean_rmse_asdr_lopo_Sibling),
            var_mare_Network = jack.var(mean_mare_asdr_lopo_Network),
            var_mare_Sibling = jack.var(mean_mare_asdr_lopo_Sibling),
            # and this is the mean difference across LOPO values
            mean_rmse_lopo_n_minus_s_jab = mean(mean_rmse_asdr_lopo_n_minus_s),
            mean_mare_lopo_n_minus_s_jab = mean(mean_mare_asdr_lopo_n_minus_s),
            mean_rmse_Network_jab = mean(mean_rmse_asdr_lopo_Network),
            mean_rmse_Sibling_jab = mean(mean_rmse_asdr_lopo_Sibling),
            mean_mare_Network_jab = mean(mean_mare_asdr_lopo_Network),
            mean_mare_Sibling_jab = mean(mean_mare_asdr_lopo_Sibling),
            .groups='drop') %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab),
         se_rmse_Network = sqrt(var_rmse_Network),
         se_rmse_Sibling = sqrt(var_rmse_Sibling),
         se_mare_Network = sqrt(var_mare_Network),
         se_mare_Sibling = sqrt(var_mare_Sibling)) %>%
  mutate(qty = 'asdr')

```


#### Get JAB uncertainty estimates in ASDR errors and error differences by age

```{r}
if (geo_name == 'city') {
  NUM_GEO_UNITS <- 27
} else if (geo_name == 'region') {
  NUM_GEO_UNITS <- 5
} else if (geo_name == 'national') {
  NUM_GEO_UNITS <- 1
}
  
# finally, aggregate the city-specific estimated variance of the estimated 
# RMSE differences across cities
jab_age_diff_ests <- jab_asdr_diff_ests %>% 
  mutate(age_rmse_lopo_n_minus_s_jab = mean_rmse_lopo_n_minus_s_jab,
         age_mare_lopo_n_minus_s_jab = mean_mare_lopo_n_minus_s_jab,
         age_var_rmse_n_minus_s_jab = var_rmse_n_minus_s_jab,
         age_var_mare_n_minus_s_jab = var_mare_n_minus_s_jab) %>%
  ungroup() %>%
  # to summarize across all rows in the tibble
  group_by(agegp10) %>%
  summarize(# overall estimate rmse diff is the average across cities
            mean_rmse_lopo_n_minus_s_jab = mean(age_rmse_lopo_n_minus_s_jab),
            mean_mare_lopo_n_minus_s_jab = mean(age_mare_lopo_n_minus_s_jab),
            # overall estimated variance in mse diff is average of city-specific 
            # variance estimates, which is (1/27)^2 times the sum of 
            # the city-specific variances
            # (we need (1/27)^2 because we're pulling a constant out of the
            #  variance -- see the appendix notes)
            var_rmse_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(age_var_rmse_n_minus_s_jab),
            var_mare_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(age_var_mare_n_minus_s_jab)
            ) %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab))
```

```{r}
jab_age_ests <- jab_asdr_ests %>%
  select(-starts_with('se')) %>%
  ungroup() %>%
  # to summarize across all rows in the tibble
  group_by(method, agegp10) %>%
  # overall estimated variance in mse diff is average of city-specific 
  # variance estimates, which is (1/27)^2 times the sum of 
  # the city-specific variances
  # (we need (1/27)^2 because we're pulling a constant out of the
  #  variance -- see the appendix notes)
  summarize(across(starts_with('var'), 
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(starts_with('var_'), list(se=sqrt), .names="{.fn}_{.col}")) %>%
  rename_with(~ str_replace(.x, '_var', ''), starts_with('se_var'))
```


#### Get JAB uncertainty estimates in ASDR error differences in total

```{r}
if (geo_name == 'city') {
  NUM_GEO_UNITS <- 27
} else if (geo_name == 'region') {
  NUM_GEO_UNITS <- 5
} else if (geo_name == 'national') {
  NUM_GEO_UNITS <- 1
}
  
# finally, aggregate the city-specific estimated variance of the estimated 
# RMSE differences across cities
jab_tot_diff_ests <- jab_geo_diff_ests %>% 
  mutate(city_rmse_lopo_n_minus_s_jab = mean_rmse_lopo_n_minus_s_jab,
         city_mare_lopo_n_minus_s_jab = mean_mare_lopo_n_minus_s_jab,
         city_var_rmse_n_minus_s_jab = var_rmse_n_minus_s_jab,
         city_var_mare_n_minus_s_jab = var_mare_n_minus_s_jab) %>%
  ungroup() %>%
  # to summarize across all rows in the tibble
  group_by(qty) %>%
  summarize(# overall estimate rmse diff is the average across cities
            mean_rmse_lopo_n_minus_s_jab = mean(city_rmse_lopo_n_minus_s_jab),
            mean_mare_lopo_n_minus_s_jab = mean(city_mare_lopo_n_minus_s_jab),
            # TODO ADD
            mean_rmse_Network_jab = mean(mean_rmse_Network_jab),
            mean_rmse_Sibling_jab = mean(mean_rmse_Sibling_jab),
            mean_mare_Network_jab = mean(mean_mare_Network_jab),
            mean_mare_Sibling_jab = mean(mean_mare_Sibling_jab),
            # overall estimated variance in mse diff is average of city-specific 
            # variance estimates, which is (1/27)^2 times the sum of 
            # the city-specific variances
            # (we need (1/27)^2 because we're pulling a constant out of the
            #  variance -- see the appendix notes)
            var_rmse_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(city_var_rmse_n_minus_s_jab),
            var_mare_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(city_var_mare_n_minus_s_jab),
            var_rmse_Network = ((1/NUM_GEO_UNITS)^2)*sum(var_rmse_Network),
            var_rmse_Sibling = ((1/NUM_GEO_UNITS)^2)*sum(var_rmse_Sibling),
            var_mare_Network = ((1/NUM_GEO_UNITS)^2)*sum(var_mare_Network),
            var_mare_Sibling = ((1/NUM_GEO_UNITS)^2)*sum(var_mare_Sibling),
            ) %>%
  mutate(across(starts_with('var_'), list(se=sqrt), .names="{.fn}_{.col}")) %>%
  rename_with(~ str_replace(.x, '_var', ''), starts_with('se_var'))

```


#### Get JAB uncertainty estimates in prob error differences within geo/age/sex group

```{r}
# this produces a tibble with one row for each
# PSU x sex group (so, 2 times the number of PSUs, \approx 8,000)
# note that, since each PSU is in exactly one city, each row here is
# a LOPO estimate that corresponds to a city/sex cell
lopo_prob_ests_wide <- lopo_prob_ests %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  select(-geo) %>%
  unnest(lopo_ests) %>%
  pivot_wider(names_from = 'method',
              values_from = c('rmse_prob_lopo', 'mare_prob_lopo'),
              id_cols=c('cb_code', 'geo', 'sex')) %>%
  mutate(rmse_prob_lopo_n_minus_s = rmse_prob_lopo_Network - rmse_prob_lopo_Sibling,
         mare_prob_lopo_n_minus_s = mare_prob_lopo_Network - mare_prob_lopo_Sibling) 

# use JAB to calculate
# uncertainty in estimated difference in RMSE between the two methods in each city,
# aggregating across sexes
jab_prob_diff_ests <- lopo_prob_ests_wide %>%
  # this renaming is just for convenience
  # (below, when we aggregate up to city, we do something else here)
  mutate(mean_rmse_prob_lopo_n_minus_s = rmse_prob_lopo_n_minus_s,
         mean_mare_prob_lopo_n_minus_s = mare_prob_lopo_n_minus_s) %>%
  # and now take the aggregated (across age/sex) LOPO estimates for 
  # each city/PSU, and aggregate these using the jackknife formula
  # this produces an estimated variance of the estimated RMSE difference 
  # within each city
  group_by(geo, sex) %>%
  # estimated variance in city MSE difference estimate, using JAB
  summarize(# aggregate across the LOPO values with the jackknife variance formula
            var_rmse_n_minus_s_jab = jack.var(mean_rmse_prob_lopo_n_minus_s),
            var_mare_n_minus_s_jab = jack.var(mean_mare_prob_lopo_n_minus_s),
            # and this is the mean difference across LOPO values
            mean_rmse_lopo_n_minus_s_jab = mean(mean_rmse_prob_lopo_n_minus_s),
            mean_mare_lopo_n_minus_s_jab = mean(mean_mare_prob_lopo_n_minus_s),
            .groups='drop') %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab)) %>%
  mutate(qty = 'prob')
```


#### Get JAB uncertainty estimates in prob error differences at geo level

```{r}
# use JAB to calculate
# uncertainty in estimated difference in RMSE between the two methods in each city,
# aggregating across sexes
jab_prob_geo_diff_ests <- lopo_prob_ests_wide %>%
  ## now use the jackknife formula to get variance estimates for each city
  group_split(geo) %>%
  map_dfr(~ {
    .x %>%
      # aggregate LOPO estimates across age/sex groups within this city and PSU
      group_by(geo, cb_code) %>%
      summarize(
                 mean_rmse_prob_lopo_n_minus_s = mean(rmse_prob_lopo_n_minus_s),
                 mean_mare_prob_lopo_n_minus_s = mean(mare_prob_lopo_n_minus_s),
                .groups='drop')
                # this should be 2 (since there are 2 sexes)
                #num_gp_check = n())
  }) %>%
  # and now take the aggregated (across age/sex) LOPO estimates for 
  # each city/PSU, and aggregate these using the jackknife formula
  # this produces an estimated variance of the estimated RMSE difference 
  # within each city
  group_by(geo) %>%
  # estimated variance in city MSE difference estimate, using JAB
  summarize(# aggregate across the LOPO values with the jackknife variance formula
            var_rmse_n_minus_s_jab = jack.var(mean_rmse_prob_lopo_n_minus_s),
            var_mare_n_minus_s_jab = jack.var(mean_mare_prob_lopo_n_minus_s),
            # and this is the mean difference across LOPO values
            mean_rmse_lopo_n_minus_s_jab = mean(mean_rmse_prob_lopo_n_minus_s),
            mean_mare_lopo_n_minus_s_jab = mean(mean_mare_prob_lopo_n_minus_s),
            .groups='drop') %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab)) %>%
  mutate(qty = 'prob')
```

#### Get JAB uncertainty estimates in prob error differences in total

```{r}
if (geo_name == 'city') {
  NUM_GEO_UNITS <- 27
} else if (geo_name == 'region') {
  NUM_GEO_UNITS <- 5
} else if (geo_name == 'national') {
  NUM_GEO_UNITS <- 1
}
  
# finally, aggregate the city-specific estimated variance of the estimated 
# RMSE differences across cities
jab_prob_tot_diff_ests <- jab_prob_geo_diff_ests %>% 
  mutate(city_rmse_lopo_n_minus_s_jab = mean_rmse_lopo_n_minus_s_jab,
         city_mare_lopo_n_minus_s_jab = mean_mare_lopo_n_minus_s_jab,
         city_var_rmse_n_minus_s_jab = var_rmse_n_minus_s_jab,
         city_var_mare_n_minus_s_jab = var_mare_n_minus_s_jab) %>%
  ungroup() %>%
  # to summarize across all rows in the tibble
  group_by(qty) %>%
  summarize(# overall estimate rmse diff is the average across cities
            mean_rmse_lopo_n_minus_s_jab = mean(city_rmse_lopo_n_minus_s_jab),
            mean_mare_lopo_n_minus_s_jab = mean(city_mare_lopo_n_minus_s_jab),
            # overall estimated variance in mse diff is average of city-specific 
            # variance estimates, which is (1/27)^2 times the sum of 
            # the city-specific variances
            # (we need (1/27)^2 because we're pulling a constant out of the
            #  variance -- see the appendix notes)
            var_rmse_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(city_var_rmse_n_minus_s_jab),
            var_mare_n_minus_s_jab = ((1/NUM_GEO_UNITS)^2)*sum(city_var_mare_n_minus_s_jab)
            ) %>%
  mutate(se_rmse_n_minus_s_jab = sqrt(var_rmse_n_minus_s_jab),
         se_mare_n_minus_s_jab = sqrt(var_mare_n_minus_s_jab))

jab_prob
```

## Calculate summary measures of estimator properties



Combine the point estimates for differences between network and sibling
with the JAB-based estimates of standard errors

### Make a dataframe with properties of difference between two methods and uncertainty for each age/sex/geo

```{r}
# NB: the point estimate is comparing est_rmse_n_minus_s 
#     and the mean of the LOPO estimates is mean_rmse_lopo_n_minus_s_jab
# these two are close, which is reassuring
# (... and analogous for other vars)
asdr_diff_properties <- asdr_diff_properties_point_estimates %>%
  select(-ends_with('Network'), -ends_with('Sibling')) %>%
  left_join(jab_asdr_diff_ests %>% select(-starts_with('var')))

prob_diff_properties <- prob_diff_properties_point_estimates %>%
  select(-ends_with('Network'), -ends_with('Sibling')) %>%
  left_join(jab_prob_diff_ests %>% select(-starts_with('var')))
```

### Make a dataframe with estimator properties and uncertainty for each method/age/sex/geo

Combine the point estimates with the JAB-based estimates of standard errors

```{r}
asdr_properties <- asdr_properties_point_estimates %>%
  left_join(jab_asdr_ests %>%
              select(geo, sex, agegp10, method, starts_with('se_'))) %>%
  pivot_wider(names_from = method,
              values_from = starts_with(c('est_', 'se_'))) %>%
  left_join(asdr_diff_properties)

prob_properties <- prob_properties_point_estimates %>%
  left_join(jab_prob_ests %>%
              select(geo, sex, method, starts_with('se_')))
```


### Make a dataframe with properties of difference between two methods and uncertainty for geo

```{r}
asdr_geo_diff_properties <- asdr_diff_properties_point_estimates %>%
  mutate(cell_est_rmse_n_minus_s = est_rmse_n_minus_s,
         cell_est_mare_n_minus_s = est_mare_n_minus_s) %>%
  group_by(geo, qty) %>%
  summarize(est_rmse_n_minus_s = mean(cell_est_rmse_n_minus_s),
            est_mare_n_minus_s = mean(cell_est_mare_n_minus_s)) %>%
  left_join(jab_geo_diff_ests %>% select(-starts_with('var')))

asdr_geo_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('cell_', .x), starts_with('est_')) %>%
  group_by(geo, qty, method) %>%
  summarize(est_bias = mean(cell_est_bias),
            est_mse = mean(cell_est_mse),
            est_mare = mean(cell_est_mare),
            est_var = mean(cell_est_var),
            est_rmse = mean(cell_est_rmse)) %>%
  pivot_wider(names_from = method,
              values_from = starts_with(c('est_'))) %>%
  # NB: jab_geo_diff_ests has uncertainty for individual ests + diffs together 
  left_join(asdr_geo_diff_properties) %>%
  rename_with(~ str_replace(.x, '(Network|Sibling)_jab', 'jab_\\1'), 
              contains('(Network|Sibling)_jab'))

prob_geo_diff_properties <- prob_diff_properties_point_estimates %>%
  mutate(cell_est_rmse_n_minus_s = est_rmse_n_minus_s,
         cell_est_mare_n_minus_s = est_mare_n_minus_s) %>%
  group_by(geo, qty) %>%
  summarize(est_rmse_n_minus_s = mean(cell_est_rmse_n_minus_s),
            est_mare_n_minus_s = mean(cell_est_mare_n_minus_s)) %>%
  left_join(jab_prob_geo_diff_ests %>% select(-starts_with('var')))
```

### Make a dataframe with properties of difference between two methods and uncertainty for age (ASDR only)

```{r}
asdr_age_diff_properties <- asdr_diff_properties_point_estimates %>%
  mutate(cell_est_rmse_n_minus_s = est_rmse_n_minus_s,
         cell_est_mare_n_minus_s = est_mare_n_minus_s) %>%
  group_by(agegp10, qty) %>%
  summarize(across(starts_with('est_'),  mean)) %>%
  left_join(jab_age_diff_ests %>% select(-starts_with('var')))

asdr_age_properties <- TODO
  # TODO - can't tell which method these ests refer to?
  left_join(jab_age_ests)

```

### Make a dataframe with properties of difference between two methods and uncertainty overall 


```{r}
asdr_tot_diff_properties <- asdr_diff_properties_point_estimates %>%
  mutate(cell_est_rmse_n_minus_s = est_rmse_n_minus_s,
         cell_est_mare_n_minus_s = est_mare_n_minus_s) %>%
  group_by(qty) %>%
  summarize(est_rmse_n_minus_s = mean(cell_est_rmse_n_minus_s),
            est_mare_n_minus_s = mean(cell_est_mare_n_minus_s)) %>%
  left_join(jab_tot_diff_ests %>% select(-starts_with('var')))

prob_tot_diff_properties <- prob_diff_properties_point_estimates %>%
  mutate(cell_est_rmse_n_minus_s = est_rmse_n_minus_s,
         cell_est_mare_n_minus_s = est_mare_n_minus_s) %>%
  group_by(qty) %>%
  summarize(est_rmse_n_minus_s = mean(cell_est_rmse_n_minus_s),
            est_mare_n_minus_s = mean(cell_est_mare_n_minus_s)) %>%
  left_join(jab_prob_tot_diff_ests %>% select(-starts_with('var')))
```




## Plot the difference in error estimates in various ways


```{r}
# point estimate (not based on JAB)
rmse_geo_diff <- asdr_geo_diff_properties %>%
  rename(est_rmse_diff = est_rmse_n_minus_s,
         est_mare_diff = est_mare_n_minus_s,
         se_rmse_diff = se_rmse_n_minus_s_jab,
         se_mare_diff = se_mare_n_minus_s_jab) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(c(1000*rmse_geo_diff$est_rmse_diff_ci_low,
                     1000*rmse_geo_diff$est_rmse_diff_ci_high))

if(geo_name == 'city') {
  annscale <- .8
  annxoff <- 0.2 
} else if (geo_name == 'region') {
  annscale <- 1.4 
  annxoff <- 0.2
} else if (geo_name == 'national') {
  annscale <- 1.8
  annxoff <- 0.2
}

diff_rmse_geo_plot <- rmse_geo_diff %>%
  ungroup() %>%
  mutate(geo = fct_reorder(geo, 
                           est_rmse_diff)) %>%
  ggplot(.) +
  geom_pointrange(aes(x = geo,
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(-6, 6)) +
  annotate(geom='text',
         label="<- Network is better ",
         #x='SE',
         x=annxoff,
         y=-biggestdiff*annscale,
         size=rel(3),
         color='red',
         angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=annxoff,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal() +
  coord_cartesian(clip = "off")

ggsave(filename=file.path(comp_out_dir, "diff_rmse_geo.pdf"),
       plot=diff_rmse_geo_plot,
       height=3.5,
       width=6)

diff_rmse_geo_plot
```



```{r}
# point estimate (not based on JAB)
rmse_age_diff <- asdr_age_diff_properties %>%
  rename(est_rmse_diff = est_rmse_n_minus_s,
         est_mare_diff = est_mare_n_minus_s,
         se_rmse_diff = se_rmse_n_minus_s_jab,
         se_mare_diff = se_mare_n_minus_s_jab) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(c(1000*rmse_age_diff$est_rmse_diff_ci_low,
                     1000*rmse_age_diff$est_rmse_diff_ci_high))

if(geo_name == 'city') {
  annscale <- .8
  annxoff <- 0.2 
} else if (geo_name == 'region') {
  annscale <- 1.4 
  annxoff <- 0.2
} else if (geo_name == 'national') {
  annscale <- 1.8
  annxoff <- 0.2
}

diff_rmse_age_plot <- rmse_age_diff %>%
  ungroup() %>%
  ggplot(.) +
  geom_pointrange(aes(x = agegp10,
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(-6, 6)) +
  annotate(geom='text',
         label="<- Network is better ",
         #x='SE',
         x=annxoff,
         y=-biggestdiff*annscale,
         size=rel(3),
         color='red',
         angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=annxoff,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal() +
  coord_cartesian(clip = "off")


ggsave(filename=file.path(comp_out_dir, "diff_rmse_age.pdf"),
       plot=diff_rmse_age_plot,
       height=3.5,
       width=6)

diff_rmse_age_plot
```


Get the total estimated difference in RMSE (averaged across all cities)

```{r}
# point estimate (not based on JAB)
rmse_tot_diff <- asdr_tot_diff_properties %>%
  rename(est_rmse_diff = est_rmse_n_minus_s,
         est_mare_diff = est_mare_n_minus_s,
         se_rmse_diff = se_rmse_n_minus_s_jab,
         se_mare_diff = se_mare_n_minus_s_jab) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(abs(c(1000*rmse_tot_diff$est_rmse_diff_ci_low, 
                     1000*rmse_tot_diff$est_rmse_diff_ci_high)))

annscale <- .5

diff_rmse_tot_plot <- rmse_tot_diff %>%
  ggplot(.) +
  geom_pointrange(aes(x = 'Average Overall RMSE Difference',
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(biggestdiff,-biggestdiff)) +
  annotate(geom='text',
           label="<- Network is better ",
           #x='SE',
           x=0.5,
           y=-biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=0.5,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal()


ggsave(filename=file.path(comp_out_dir, "diff_rmse_tot.pdf"),
       plot=diff_rmse_tot_plot,
       height=3.5,
       width=3.5)

diff_rmse_tot_plot
```


## Save results for plots

TODO - LEFT OFF HERE
- TO ADD to save for plots
  - network and sibling errs and cis (not just difference)
  - re-run to get CIs for MARE results
- re-run for vr / adj vr and for all geos
- then go to 06_plots and fix to work with these results
- ALSO revisit heatmaps and get margins to use these results

```{r}
# err_diffs_jab.csv

asdr_tot_err_diffs_jab <- 
  asdr_tot_diff_properties %>%
    rename(est_rmse_diff = est_rmse_n_minus_s,
           est_mare_diff = est_mare_n_minus_s,
           se_rmse_diff = se_rmse_n_minus_s_jab,
           se_mare_diff = se_mare_n_minus_s_jab) %>%
    mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
           est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff) %>%
    mutate(est_mare_diff_ci_low = est_mare_diff - 1.96*se_mare_diff,
           est_mare_diff_ci_high = est_mare_diff + 1.96*se_mare_diff) %>%
  pivot_longer(
    cols=-qty
  ) %>%
  mutate(geo_name = geo_name) %>%
  mutate(loss = str_extract(name, "rmse|mare"),
         name = str_replace(name, "_rmse_|_mare_", "_"))

prob_tot_err_diffs_jab <- 
  prob_tot_diff_properties %>%
    rename(est_rmse_diff = est_rmse_n_minus_s,
           est_mare_diff = est_mare_n_minus_s,
           se_rmse_diff = se_rmse_n_minus_s_jab,
           se_mare_diff = se_mare_n_minus_s_jab) %>%
    mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
           est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff) %>%
    mutate(est_mare_diff_ci_low = est_mare_diff - 1.96*se_mare_diff,
           est_mare_diff_ci_high = est_mare_diff + 1.96*se_mare_diff) %>%
  pivot_longer(
    cols=-qty
  ) %>%
  mutate(geo_name = geo_name) %>%
  mutate(loss = str_extract(name, "rmse|mare"),
         name = str_replace(name, "_rmse_|_mare_", "_"))

err_diffs_jab <- bind_rows(asdr_tot_err_diffs_jab,
                           prob_tot_err_diffs_jab) %>%
  mutate(comparison_name = params$comparison_name)

write_csv(err_diffs_jab,
          file.path(comp_out_dir, "err_diffs_jab.csv"))

# this file is used in 06_plots.Rmd

err_diffs_jab
```



# National and regional analyses ends here; rest is only for cities

```{r}
if(geo_name %in% c('national', 'region')) {
  toc()
  knitr::knit_exit()
}
```

# Headline plot

3 panels: MSE, Bias, Var (point for net, point for sib)

```{r}

```


# Plots of Bias / Variance / MSE

Bias: 3 panels - net bias by age, sib bias by age, net vs sib by age

```{r}

```

Var: 3 panels - net var by age, sib var by age, net vs sib

```{r}

```


MSE: 3 panels - net mse by age, sib mse by age, net vs sib

```{r}

```



# Maps / Geography

```{r}
# join in city names for titles
state.city.map <- city.dat %>% select(state_abbrev, region, state_name, city_name=municipio)
state.city.map <- state.city.map %>%
  mutate(title = paste0(city_name, " (", state_abbrev, ")")) %>%
  mutate(geo = state_abbrev)
  #mutate(title = paste0(city_name, ",\n", state_name))

#br_customgrid <- br_grid1 %>% 
br_customgrid <- br_states_grid1 %>% 
  select(-name) %>%
  left_join(state.city.map %>% select(code=state_abbrev, name=title))
```

## Summarize raw / realized errors by geography

All ests, by geography

```{r calculate-errs-in-asdrs-by-geo}
comp_asdrs_bygeo <- comp_asdrs %>%
  group_by(method, geo) %>%
  summarize(geo_mse = mean(delta2),
            #geo_are = sum(abs(delta_rel))) 
            # this should be the mean, right?
            geo_are = mean(abs(delta_rel))) 

# difference in MSE (network - sibling)
comp_asdrs_bygeo_wide <- comp_asdrs_bygeo %>%
  select(-geo_are) %>%
  pivot_wider(names_from=method, values_from=geo_mse)  %>%
  mutate(n.minus.s = Network - Sibling)

# difference in ARE (network - sibling)
comp_rel_asdrs_bygeo_wide <- comp_asdrs_bygeo %>%
  select(-geo_mse) %>%
  pivot_wider(names_from=method, values_from=geo_are) %>%
  mutate(n.minus.s = Network - Sibling)


comp_asdrs_bygeoas <- comp_asdrs %>%
  group_by(method, geo, sex, agegp10) %>%
  summarize(geo_mse = mean(delta2),
            # this should be the mean, right?
            geo_are = mean(abs(delta_rel)),
            # not absolute relative error (so, can be negative)
            geo_re = mean(delta_rel_notabs)) %>%
  ungroup() %>%
  mutate(geo_rmse = sqrt(geo_mse))

# difference in MSE (network - sibling)
comp_asdrs_bygeoas_wide <- comp_asdrs_bygeoas %>%
  select(-geo_are, -geo_re, -geo_rmse) %>%
  pivot_wider(names_from=method, values_from=geo_mse)  %>%
  mutate(n.minus.s = Network - Sibling)

comp_asdrs_byas <- comp_asdrs %>%
  group_by(method, sex, agegp10) %>%
  summarize(as_mse = mean(delta2),
            as_are = mean(abs(delta_rel)),
            # not absolute relative error (so, can be negative)
            as_re = mean(delta_rel_notabs))  
```


## Plot the difference between the two methods against the estimated VR completeness

Plot the difference between the two methods (MSE) against the estimated completeness

```{r comp-errs-mse-vrcompleteness, fig.height=3.5, fig.width=3.5}
## NB: only have completeness at the state level...
if(geo_name == 'city') {

# difference in MSE
comp_df <- comp_asdrs_bygeo_wide

comp_df_withvr <- comp_df %>%
  left_join(ibge_vr_completeness %>%
              select(geo, ibge_est_vrcov = mean_sim_cov_pct))

biggestdiff <- max(abs(comp_df_withvr$n.minus.s))
xrange <- c(-biggestdiff, biggestdiff)

## controls how far out annotations go
annscale <- .6

geo_err_mse_vr_comp <-
  comp_df_withvr %>%
        mutate(geo = fct_reorder(geo, n.minus.s)) %>%
  ggplot(.) +
  geom_text(aes(y=n.minus.s,
                x=ibge_est_vrcov,
                label=geo)) +
  #geom_vline(xintercept=0, color='dark grey') +
  #geom_point(aes(y=state_abbrev, x=n.minus.s)) +
  theme_minimal() +
  ylab("Network estimate MSE - Sibling estimate MSE") +
  xlab("Estimated VR completeness") +
  expand_limits(y=xrange) +
  annotate(geom='text',
           label="<- Network is better ",
           #x='SE',
           x=100,
           y=-biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=100,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme(axis.title.x=element_text(size=rel(.8))) +
  ## see
  ## https://stackoverflow.com/questions/12409960/ggplot2-annotate-outside-of-plot
  ## for how this helps plot not clip annotations
  coord_cartesian(clip='off') +
  NULL


ggsave(filename=file.path(comp_out_dir, "geo_err_summ_mse_vrsens.pdf"),
       plot=geo_err_mse_vr_comp,
       height=3.5,
       width=3.5)
knitr::plot_crop(file.path(comp_out_dir, "geo_err_summ_mse_vrsens.pdf"))

geo_err_mse_vr_comp

}
```

## Hexgrid maps

Helper fn 

```{r city-method-mare-map, fig.height=4.5, fig.width=3}
  
comp_df <- comp_rel_asdrs_bygeo_wide
  
##
## data - dataset to use, already filtered (so either males or females)
##        needs a column called 'geo'
## qoivar - the value to plot
## name - the label for the qoi
br_compare_choro_map <- function(data, qoivar, name, 
                                 title=NULL, 
                                 labels=TRUE, 
                                 fillscale=NULL,
                                 logfill=FALSE,
                                 hex=TRUE) {
    
  mapobj <- readRDS(file.path(out_dir, "brazil_map.rds"))
  
  # should we plot a hex map? or a political map?
  if(hex) {
    # hexmap
    if(geo_name == 'region') {
      basemap <- mapobj$hexmap_region
    } else {
      basemap <- mapobj$hexmap
    }
    # political map
  } else {
    basemap <- mapobj$map
  }
  
  if(geo_name == 'city') {
    mapraw <- basemap %>%
      mutate(geo = postal) 
  } else {
    mapraw <- basemap %>%
      mutate(geo = region) 
  }
  
  mapdat <- mapraw %>%
    left_join(data %>% rename(qoi = qoivar))
  
  capdat <- mapobj$capitals
  
  if(is.null(fillscale)) {
    # default fill scale
    plot_fill_scale <- scale_fill_distiller(name=name, type='div')
  } else {
    plot_fill_scale <- fillscale
  }
  
  if (logfill) {
    plot_fill_scale <- plot_fill_scale + scale_color_continuous(trans=log10)
  }
  

  # for removing the background from ggplots
  remove_background <- theme(panel.background = element_blank(),
            panel.border = element_blank(),
            panel.grid.major = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.y = element_blank(),
            axis.text.y = element_blank()) 
  
  cur_map <- 
    ggplot(data=mapdat) + 
      theme_bw(base_size=5) +
      geom_sf(aes(fill=qoi), 
              linetype='dotted', 
              alpha=.8) +
    plot_fill_scale +
    #log_scale_fill +
    remove_background  +
    xlab('') + ylab('') +
    theme(legend.position=c(.2,.3),
          legend.direction='vertical',
          legend.text=element_text(size=8),
          legend.title=element_text(size=8, face='bold')) +
    NULL
  
  if(labels) {
    cur_map <- cur_map +
      geom_sf(data=capdat) +
      geom_text_repel(data=capdat,
                      aes(x=lon, y=lat, 
                          label=glue::glue("{municipio} ({state_abbrev})")),
                      size=rel(3))
  }
  
  if(! is.null(title)) {
    cur_map <- cur_map + ggtitle(title)
  }
  
  return(cur_map)
}

# see 
# https://github.com/tidyverse/ggplot2/issues/1012
scale_fill_log10 <- function(...) {
  scale_fill_continuous(..., trans = scales::log10_trans())
}

# make maps for each age/sex group and assemble
# them into one figure
br_hexgrid_map <- function(qoivar,
                           qoiname,
                           scale_lims=NULL,
                           fillscale=NULL,
                           logfill=FALSE) {
  
  # TODO 
  if(! is.null(scale_lims)) {
    cur_lims <- scale_lims*1.05 
  } else {
    cur_lims <- NULL
  }
  
  if(logfill) {
    plot_logfill <- scale_fill_log10()
  } else {
    plot_logfill <- NULL
  }
  
  if(! is.null(fillscale)) {
    plot_fillscale <- fillscale
  } else {
    plot_fillscale <- scale_fill_distiller(name=qoiname, 
                                           palette = 'Spectral',
                                           limits=cur_lims,
                                           oob=scales::squish,
                                           type='div') 
  }
  
  maps_indiv <- comp_asdrs_bygeoas %>%
    group_by(sex, method, agegp10) %>%
    group_modify(function(cur_df, key) {
      
      cur_sex <- key$sex[1]
      cur_agegp10 <- key$agegp10[1]
      cur_method <- key$method[1]
      
      cur_map_errs <- br_compare_choro_map(cur_df,
                                           qoivar=qoivar,
                                           title=glue::glue('{cur_method}: {cur_sex}, {cur_agegp10}'),
                                           name=glue::glue('{cur_method} {qoiname}'),
                                           labels=FALSE,
                                           fillscale=plot_fillscale,
                                           hex=TRUE) +
        plot_logfill
      return(tibble(map_errs=list(cur_map_errs)))
      
    })
  
  layout <- "
  AF#KP
  BG#LQ
  CH#MR
  DI#NS
  EJ#OT
  "
  
  ppw <- 4 # plot panel width (relative)
  spw <- 1 # space panel width (relative)
  
  
  maps_array <- maps_indiv %>% 
    pull(map_errs) %>%
    wrap_plots(design=layout,
               widths=c(ppw, ppw, spw, ppw, ppw)) +
    plot_layout(guides='collect') &
    theme(legend.position='bottom',
          legend.direction='horizontal',
          plot.title=element_text(hjust=0.5)) 
  
  
  meta_layout <- "
  ##FF###MM##
  #NNSS#TTUU#
  APPPPPPPPPV
  BPPPPPPPPPW
  CPPPPPPPPPX
  DPPPPPPPPPY
  EPPPPPPPPPZ
  "
  
  final_maps <- wrap_plots(
     A=wrap_elements(grid::textGrob("18-24")), 
     B=wrap_elements(grid::textGrob("25-34")), 
     C=wrap_elements(grid::textGrob("35-44")), 
     D=wrap_elements(grid::textGrob("45-54")), 
     E=wrap_elements(grid::textGrob("55-64")), 
     V=wrap_elements(grid::textGrob("18-24")), 
     W=wrap_elements(grid::textGrob("25-34")), 
     X=wrap_elements(grid::textGrob("35-44")), 
     Y=wrap_elements(grid::textGrob("45-54")), 
     Z=wrap_elements(grid::textGrob("55-64")), 
     F=wrap_elements(grid::textGrob("Female")),
     M=wrap_elements(grid::textGrob("Male")),
     N=wrap_elements(grid::textGrob("Network")),
     T=wrap_elements(grid::textGrob("Network")),
     S=wrap_elements(grid::textGrob("Sibling")),
     U=wrap_elements(grid::textGrob("Sibling")),
     P=maps_array,
     design=meta_layout,
   heights=c(1,1,rep(6,5))) +
   plot_annotation(caption="Values outside of limits squished to limits.")
  
  return(final_maps)
}
```

Plot age/sex RMSE for estimates

```{r method_map_as_rmse}
method_rmse_as_maps <- br_hexgrid_map(qoivar='geo_rmse',
                                      qoiname='RMSE',
                                      scale_lims=c(0,10))
      
saveRDS(method_rmse_as_maps, file.path(comp_out_dir, "method_rmse_agesex_map.rds"))
ggsave(filename=file.path(comp_out_dir, "method_rmse_agesex_map.pdf"),
       plot=method_rmse_as_maps,
       height=10,
       width=8)
ggsave(filename=file.path(comp_out_dir, "method_rmse_agesex_map.png"),
       plot=method_rmse_as_maps,
       height=10,
       width=8)

method_rmse_as_maps
```

## Summarize Geographical relationships with Moran's I

Helper function to calculate Moran's I

```{r}

calculate_moran_I <- function(qoi_df, 
                              qoi_var, 
                              alternative = 'two.sided',
                              # other args for spdep::moran.test
                              ...) {

  mapobj <- readRDS(file.path(out_dir, "brazil_map.rds"))
  
  if(geo_name == 'city') {
    mapraw <- mapobj$map %>%
      mutate(geo = postal) 
  } else {
    mapraw <- mapobj$map %>%
      mutate(geo = region) %>%
      group_by(geo) %>%
      summarize() %>%
      ungroup()
  }
  
  # see
  # https://mgimond.github.io/Spatial/spatial-autocorrelation-in-r.html
  neighbors <- spdep::poly2nb(mapraw) 
  neighbors_weight <- spdep::nb2listw(neighbors, style="W", zero.policy=TRUE)
  
  #comp_rel_asdrs_bygeo_wide,
  #qoivar='n.minus.s'
                                        
  mapdat <- mapraw %>%
    left_join(qoi_df %>% rename(qoi = all_of(qoi_var)))
  
  res <- spdep::moran.test(mapdat[['qoi']], 
                           listw=neighbors_weight,
                           alternative=alternative,
                           ...)
  
  res$moran_I <- round(res$estimate[1],2)
  res$p_value <- round(res$p.value, 2)
  res$desc <- glue::glue("Moran's I, p-value calculated based on {alternative}",
                         .envir = res)
    
  # rename 'method' slot, since we use that for something else
  res$moran_method <- res$method
  res$method <- NULL
  
  return(res)
}

# helper function to coerce results of Moran's I calculation
# to a tibble row
moran_I_to_tibble <- function(res, ...) {
  class(res) <- NULL
  res$estimate <- list(res$estimate)
  return(as_tibble_row(c(res, ...)))
}

```

### Moran's I for MSE values

Calculate Moran's I for MSE values

```{r}
mse_moran_I <- comp_asdrs_bygeoas_wide %>%
  rename(diff = 'n.minus.s') %>%
  pivot_longer(cols=c('Network', 'Sibling', 'diff'),
               names_to = 'method',
               values_to = 'value') %>%
  ungroup() %>%
  group_by(geo, method) %>%
  summarize(value = mean(value)) %>%
  group_by(method) %>%
  group_map(function(cur_df, key) {
    
    cur_method <- key$method[1]
    
    res <- calculate_moran_I(cur_df, 'value')
    
    res$sex <- 'both'
    res$agegp10 <- 'all'
    res$method <- cur_method
    
    return(res)
    
  })

spatial_res_mse <- map_dfr(mse_moran_I,
                           ~ moran_I_to_tibble(.x,
                                               qty = 'MSE'))
```

Calculate Moran's I for MSE values by age/sex group

```{r}
mse_as_moran_I <- comp_asdrs_bygeoas_wide %>%
  rename(diff = 'n.minus.s') %>%
  pivot_longer(cols=c('Network', 'Sibling', 'diff'),
               names_to = 'method',
               values_to = 'value') %>%
  ungroup() %>%
  group_by(sex, method, agegp10) %>%
  group_map(function(cur_df, key) {
    
    cur_sex <- key$sex[1]
    cur_agegp10 <- key$agegp10[1]
    cur_method <- key$method[1]
    
    res <- calculate_moran_I(cur_df, 'value')
    
    res$sex <- cur_sex
    res$agegp10 <- cur_agegp10
    res$method <- cur_method
    
    return(res)
    
  })

spatial_res_mse_as <- map_dfr(mse_as_moran_I,
                              ~ moran_I_to_tibble(.x,
                                                  qty = 'MSE'))
```

```{r}
moran_I_df <- bind_rows(spatial_res_mse,
                        spatial_res_mse_as)


write_csv(moran_I_df %>% unnest_wider(estimate) %>% arrange(p_value),
          file.path(comp_out_dir, "moran_I.csv"))
```

Moran's I values that are significant at $p=0.05$ level

```{r}
moran_I_df %>% filter(p_value < 0.05)
```

# Heatmaps showing error

Create a dataset `all_err_diffs_boot`
which has a row for each geo/sex/agegp/boot_idx that has, for Sibling and Network
  - delta = (estimate - truth) [diff between estimate and truth]
  - delta2 = (estimate - truth)^2 [delta squared - used in calculating MSE and RMSE]
  - delta_rel = |estimate - truth| / truth [absolute relative diff between estimate and truth]
  - delta_rel_notabs = (estimate - truth) / truth [relative diff between estimate and truth, with no absolute value taken]
  - estimate (the actual estimate)
  - gs_asdr (the gold standard value)
  
```{r}
all_err_diffs_boot <- comp_asdrs_boot %>%
  rename(estimate = post_mean_asdr) %>%
  pivot_wider(id_cols = c('geo', 'sex', 'agegp10', 'boot_idx', 'gs_asdr'),
              names_from=method,
              values_from=c(starts_with('delta'), 'estimate'))
```

Create a dataset `geo_err_diffs_boot` which summarizes errors within each geographical area;
it has a row for each geo/boot_idx that has, for Network/Sibling
  - mean_delta
  - mean_delta2
  - mean_delta_rel
it also has differences:
  - mean_diff_rel
  - mean_diff_mse
  - mean_diff_rmse = sqrt(mean_delta2_Network) - sqrt(mean_delta2_Sibling)
  
```{r}
## given a dataset assumed to be grouped in some way 
## aggregate errors and calculate rmse after aggregating
summ_estimate_errs <- function(df) {
  df %>%
    summarize(# sibling
              mean_delta_Sibling = mean(delta_Sibling),
              mean_delta2_Sibling = mean(delta2_Sibling),
              mean_delta_rel_Sibling = mean(delta_rel_Sibling),
              mean_delta_rel_notabs_Sibling = mean(delta_rel_notabs_Sibling), 
              # network 
              mean_delta_Network = mean(delta_Network),
              mean_delta2_Network = mean(delta2_Network),
              mean_delta_rel_Network = mean(delta_rel_Network),
              mean_delta_rel_notabs_Network = mean(delta_rel_notabs_Network)) %>%
    ungroup() %>%
    mutate(mean_diff_rel = mean_delta_rel_Network - mean_delta_rel_Sibling,
           mean_diff_rel_notabs = mean_delta_rel_notabs_Network - mean_delta_rel_notabs_Sibling,
           mean_diff_mse = mean_delta2_Network - mean_delta2_Sibling,
           mean_diff_rmse = sqrt(mean_delta2_Network) - sqrt(mean_delta2_Sibling),
           mean_diff_raw = mean_delta_Network - mean_delta_Sibling)
}

## given a summarized and grouped dataset,
## calculate summaries (point ests + cis) for network, sibling, and diffs
calc_ci_errs <- function(df) {
  df %>%
  summarize(
            ## sibling
            sib_mare = mean(mean_delta_rel_Sibling),
            sib_mare_ci_low = quantile(mean_delta_rel_Sibling, .025),
            sib_mare_ci_high = quantile(mean_delta_rel_Sibling, .975),
            sib_mse = mean(mean_delta2_Sibling),
            sib_mse_ci_low = quantile(mean_delta2_Sibling, .025),
            sib_mse_ci_high = quantile(mean_delta2_Sibling, .975),
            sib_rmse = sqrt(mean(mean_delta2_Sibling)),
            sib_rmse_ci_low = sqrt(quantile(mean_delta2_Sibling, .025)),
            sib_rmse_ci_high = sqrt(quantile(mean_delta2_Sibling, .975)),
            sib_raw = mean(mean_delta_Sibling),
            sib_raw_ci_low = quantile(mean_delta_Sibling, .025),
            sib_raw_ci_high = quantile(mean_delta_Sibling, .975),
            sib_rel_notabs = mean(mean_delta_rel_notabs_Sibling),
            sib_rel_notabs_ci_low = quantile(mean_delta_rel_notabs_Sibling, .025),
            sib_rel_notabs_ci_high = quantile(mean_delta_rel_notabs_Sibling, .975),
            ## network 
            net_mare = mean(mean_delta_rel_Network),
            net_mare_ci_low = quantile(mean_delta_rel_Network, .025),
            net_mare_ci_high = quantile(mean_delta_rel_Network, .975),
            net_mse = mean(mean_delta2_Network),
            net_mse_ci_low = quantile(mean_delta2_Network, .025),
            net_mse_ci_high = quantile(mean_delta2_Network, .975),
            net_rmse = sqrt(mean(mean_delta2_Network)),
            net_rmse_ci_low = sqrt(quantile(mean_delta2_Network, .025)),
            net_rmse_ci_high = sqrt(quantile(mean_delta2_Network, .975)),
            net_raw = mean(mean_delta_Network),
            net_raw_ci_low = quantile(mean_delta_Network, .025),
            net_raw_ci_high = quantile(mean_delta_Network, .975),
            net_rel_notabs = mean(mean_delta_rel_notabs_Network),
            net_rel_notabs_ci_low = quantile(mean_delta_rel_notabs_Network, .025),
            net_rel_notabs_ci_high = quantile(mean_delta_rel_notabs_Network, .975),
            ## differences    
            diff_mare = mean(mean_diff_rel),
            diff_mare_ci_low = quantile(mean_diff_rel, .025),
            diff_mare_ci_high = quantile(mean_diff_rel, .975),
            diff_mse = mean(mean_diff_mse),
            diff_mse_ci_low = quantile(mean_diff_mse, .025),
            diff_mse_ci_high = quantile(mean_diff_mse, .975),
            diff_rmse = mean(mean_diff_rmse),
            diff_rmse_ci_low = quantile(mean_diff_rmse, .025),
            diff_rmse_ci_high = quantile(mean_diff_rmse, .975),
            diff_raw = mean(mean_diff_raw),
            diff_raw_ci_low = quantile(mean_diff_raw, .025),
            diff_raw_ci_high = quantile(mean_diff_raw, .975),
            diff_rel_notabs = mean(mean_diff_rel_notabs),
            diff_rel_notabs_ci_low = quantile(mean_diff_rel_notabs, .025),
            diff_rel_notabs_ci_high = quantile(mean_diff_rel_notabs, .975)
            )
}

## given df with errors and grouping vars,
## calculate point ests and cis for those grouping vars,
## based on the general principle of calculating aggregates within
## each bootstrap rep, then summarizing across bootstrap reps
##
## example:
##   if groups is age and sex, then
##       1) calculate mare and rmse for each age and sex group within each boot rep
##       2) then calculate average and 95% CI of these age/sex mare and rmse values across boot reps
calc_summ_errs <- function(df, groups) {
  df %>%
    ## calculate rmse, mare, etc within groups and boot rep
    group_by(across({{groups}}), boot_idx) %>%
    summ_estimate_errs() %>%
    ## now summarize across boot reps, within groups
    group_by(across({{groups}})) %>%
    calc_ci_errs()
}
```

```{r}
geo_err_diffs_summ <-
  all_err_diffs_boot %>%
  calc_summ_errs(geo)

agesex_err_diffs_summ <-
  all_err_diffs_boot %>%
  calc_summ_errs(c(sex, agegp10))

geo_agesex_err_diffs_summ <-
  all_err_diffs_boot %>%
  calc_summ_errs(c(geo, sex, agegp10))

## this should calculate errs across cities for each bootstrap rep,
## then take ci, etc, over bootstrap reps
tot_err_diffs_summ <- all_err_diffs_boot %>%
  group_by(boot_idx) %>%
  summ_estimate_errs() %>%
  mutate(dummy=1) %>%
  group_by(dummy) %>%
  calc_ci_errs() %>%
  ungroup()
```

```{r}
# see
# https://stackoverflow.com/questions/60016390/set-axes-limits-in-patchwork-when-combining-ggplot2-objects
apply_consistent_y_lims <- function(this_plot){
    num_plots <- length(this_plot$layers)
    y_lims <- lapply(1:num_plots, function(x) ggplot_build(this_plot[[x]])$layout$panel_scales_y[[1]]$range$range)
    min_y <- min(unlist(y_lims))
    max_y <- max(unlist(y_lims))
    this_plot & ylim(min_y, max_y)
}
```


```{r}
## NB: this fn assumes that the environment has
##   geo_err_diffs_summ
##   agesex_err_diffs_summ
##   geo_agesex_err_diffs_summ
err_breakdown_plot <- function(err_metric, 
                               err_metric_name, 
                               diff = FALSE) {
  
  if (diff) {
    fill_scale <- scale_fill_gradient2(low='yellow', high='red', midpoint=0)
    vline <- geom_vline(xintercept = 0, color='grey')
    hline <- geom_hline(yintercept = 0, color='grey')
    symm_x <- lemon::scale_x_symmetric(mid=0)
  } else {
    fill_scale <- scale_fill_gradient(low='white', high='red')
    vline <- NULL
    hline <- NULL
    symm_x <- NULL
  }
  
  ## age-sex plot
  as_plot <- agesex_err_diffs_summ %>%
    ## rename current error
    rename_with(~ str_replace(.x, err_metric, 'err'),
                .cols=starts_with(err_metric)) %>%
    ggplot(.) +
    geom_pointrange(aes(x=agegp10, 
                        ymin=err_ci_low,
                        ymax=err_ci_high,
                        y=err)) +
    facet_wrap(~ sex) +
    theme_minimal() +
    xlab("") +
    expand_limits(y = 0) +
    hline + 
    ylab(err_metric_name)

   geo_err_diffs_summ_forplot <- geo_err_diffs_summ %>%
    ## rename current error
    rename_with(~ str_replace(.x, err_metric, 'err'),
                .cols=starts_with(err_metric)) %>%
     mutate(geo = factor(geo)) %>%
     mutate(geo = fct_reorder(geo, err))
   
   geo_lev_order <- levels(geo_err_diffs_summ_forplot$geo)
   
   city_plot <- geo_err_diffs_summ_forplot %>%
     ggplot(.) +
     geom_pointrange(aes(x=err, 
                         xmin=err_ci_low,
                         xmax=err_ci_high,
                         y=geo)) +
     theme_minimal() +
     xlab(err_metric_name) +
     expand_limits(x = 0) +
     symm_x +
     vline +
     ylab("")
   
   ## summarize errors across bootstrap reps within each city/age/sex gp
   hm <- geo_agesex_err_diffs_summ %>%
    ## rename current error
    rename_with(~ str_replace(.x, err_metric, 'err'),
                .cols=starts_with(err_metric)) %>%
     mutate(geo = factor(geo)) %>%
     mutate(geo = fct_relevel(geo, geo_lev_order)) %>%
     ggplot(.) +
     geom_tile(aes(x=agegp10, y=geo, fill=err)) +
     facet_wrap(~ sex) +
     theme_minimal() +
     xlab("") +
     ylab("") +
     theme(legend.position = 'bottom') +
     fill_scale +
     expand_limits(fill = 0) +
     #coord_equal() +
     guides(fill = guide_colorbar(title = err_metric_name,
                                  title.position="top"))
     #scale_fill_gradient(low='black', high='red')   
  
  # 1 : heatmap
  # 2 : city agg errs
  # 3 : age-sex errs
  design <- "
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    333333333334444
    333333333334444
    333333333334444
    333333333334444
  "
  #p1 <- (hm + ggtitle("City, Probability")) + 
  #      (city_plot + ggtitle("City, Age-specific death rate")) + 
  #      (as_plot + ggtitle("Region, Probability")) +
  test <- (hm + ggtitle("A")) + 
        (city_plot + ggtitle("B")) + 
        (as_plot + ggtitle("C")) +
        guide_area() +
    plot_layout(guides='collect', design=design)   
  
  return(test)
}

```


```{r}
# height / width for saved plots
pheight <- 10
pwidth <- 7.5
```


### MARE

Network MARE

```{r}
err_breakdown_mare_net <- err_breakdown_plot('net_mare', 
                                             'Network\nMARE')

#saveRDS(err_breakdown_mare_net, 
#        file.path(comp_out_dir, "err_breakdown_mare_net.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_mare_net.pdf"),
       plot=err_breakdown_mare_net,
       height=pheight,
       width=pwidth)

err_breakdown_mare_net
```

Sibling MARE

```{r}
err_breakdown_mare_sib <- err_breakdown_plot('sib_mare', 
                                             'Sibling\nMARE')

#saveRDS(err_breakdown_mare_sib, 
#        file.path(comp_out_dir, "err_breakdown_mare_sib.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_mare_sib.pdf"),
       plot=err_breakdown_mare_sib,
       height=pheight,
       width=pwidth)

err_breakdown_mare_sib
```

### RMSE


Network RMSE

```{r}
err_breakdown_rmse_net <- err_breakdown_plot('net_rmse', 
                                             'Network\nRMSE')

#saveRDS(err_breakdown_rmse_net, 
#        file.path(comp_out_dir, "err_breakdown_rmse_net.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_rmse_net.pdf"),
       plot=err_breakdown_rmse_net,
       height=pheight,
       width=pwidth)

err_breakdown_rmse_net
```

Sibling RMSE

```{r}
err_breakdown_rmse_sib <- err_breakdown_plot('sib_rmse', 
                                             'Sibling\nRMSE')

#saveRDS(err_breakdown_rmse_sib, 
#        file.path(comp_out_dir, "err_breakdown_rmse_sib.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_rmse_sib.pdf"),
       plot=err_breakdown_rmse_sib,
       height=pheight,
       width=pwidth)

err_breakdown_rmse_sib
```


```{r}
toc()
```


