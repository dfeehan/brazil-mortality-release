---
title: "Vital registration comparison"
params:
  ## comparison_name - are we comparing to VR to the adjusted VR?
  comparison_name: "vr_comparison"
  #comparison_name: "vr_adj_comparison"
  ## geo_name - are we analyzing at the city, region, or national level?
  geo_name: "city"
  #geo_name: "region"
  #geo_name: "national"
  ## do_12mo: if true, run the sibling 12-month estimates
  #do_12mo: true
  do_12mo: false
output:
  html_document:
    df_print: paged
---


TODO - 20260122 call

* first plot:
  - average estimates across 27 cities by age/sex, w/ uncertainty intervals from bootstrap
  - third panel: difference in estimates? or the truth/VR? => maybe the truth?

* big error bar on old male network variance 
  -> TODO multiply by 1,000 once early on
  -> negative (normal approx)
  -> look at specific city estimates
  -> does BVD hold for JAB estimates?
  -> how could this be real?
    - high variance in reported deaths as a fn of PSUs?
    - ... but we topcode
  -> DOUBLE CHECK that Efron uses Normal approx for uncertainty intervals based on JAB
* BIAS plots 
  -> line at 0 for Net + Sib
  -> difference: should be |Net Bias| - |Sib Bias|
  
* moran's I: does it look the same as before? look at map, etc




This file makes the comparison between the two survey-based estimates
(sibling and network) and the vital registration data.

It uses parameters to choose whether the comparison is at the state or regional level,
and to choose whether the comparison is to the adjusted or unadjusted vital registration.

For replication, this file is not supposed to be run directly; it is run by another
notebook.

```{r}
options(knitr.duplicate.label = "allow")
```

```{r}
library(tidyverse)
library(geofacet)
#devtools::install_github("dgrtwo/drlib")
library(drlib) # has reorder_within / scale_x_reordered for plots

library(gtable) # for customizing map
library(ggplotify) # for customizing map

library(ggforce) # for paginating faceted output
library(latex2exp)
library(broom)

library(gridExtra)

library(demogR)

library(ggrepel)
library(patchwork)
library(tictoc)
library(glue)

## this has coord_obs_pred, which is helpful for plots
library(tune)

# for calculating moran's I
# (spatial autocorrelation)
library(spdep)

# this has color scale
library(viridis)

# to avoid issues w/ spherical geometry (minor detail in making maps)
# see
# https://gis.stackexchange.com/questions/404385/r-sf-some-edges-are-crossing-in-a-multipolygon-how-to-make-it-valid-when-using
sf_use_s2(FALSE)

# has a helper function for symmetric y axis
# devtools::install_github("stefanedwards/lemon")
# (on 20230613)
library(lemon)

library(here)
```

```{r}
comparison_name <- params$comparison_name 

geo_name <- params$geo_name 
```

```{r}
out_dir <- here('out')
data_dir <- here('data')

vr_dir <- file.path(data_dir, 'vr_prepped')

comp_out_dir0 <- file.path(out_dir, comparison_name)
comp_out_dir <- file.path(comp_out_dir0, geo_name)
dir.create(comp_out_dir0, showWarnings = FALSE)
dir.create(comp_out_dir, showWarnings = FALSE)
```

```{r}
tic(glue::glue("Running comparison for {comparison_name} / {geo_name}"))
```


Some aesthetics for the plots

```{r}
color_sib <- "#FC4E07"
color_net <- "#00AFBB"
color_gs <- "black"

shape_sib <- 0
shape_net <- 5
shape_gs  <- 16

region_pal <- tribble(~ region, ~ color,
                      'NO', 'blue',
                      'NE', 'orange',
                      'CW', 'red',
                      'SE', 'green',
                      'SO', 'purple')

age_scale_color <- scale_color_viridis(discrete=TRUE, direction=-1)
```

# Open up the estimates

Load vital registration reference estimates

```{r}
if(comparison_name == 'vr_comparison') {
  
  if(geo_name == 'city') {
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_asdrs.csv")) %>%
      rename(geo = state_abbrev)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_47q18.csv")) %>%
      rename(geo = state_abbrev)
    
  } else if(geo_name == 'region') {

    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_region_asdrs.csv")) %>%
      rename(geo = region)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_region_47q18.csv")) %>%
      rename(geo = region)
    
  } else if (geo_name == 'national') {
    
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_national_asdrs.csv")) %>%
      mutate(geo = 'national')
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_national_47q18.csv")) %>%
      mutate(geo = 'national')
    
  }
  
} else if (comparison_name == 'vr_adj_comparison') {
  
  if(geo_name == 'city') {
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_asdrs_adj.csv"))  %>%
      rename(geo = state_abbrev)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_47q18_adj.csv")) %>%
      rename(geo = state_abbrev)
    
  } else if (geo_name == 'region') {
  
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_region_asdrs_adj.csv")) %>%
      rename(geo = region)
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_region_47q18_adj.csv")) %>%
      rename(geo = region)
    
  } else if (geo_name == 'national') {
    
    gs_asdrs <- read_csv(file.path(vr_dir, 
                                   "vr_national_asdrs_adj.csv")) %>%
      mutate(geo = 'national')
    
    gs_probs <- read_csv(file.path(vr_dir, 
                                   "vr_national_47q18_adj.csv")) %>%
      mutate(geo = 'national')
    
  }
}
```

Load sibling estimates

```{r}
if(geo_name == 'city') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_boot.csv')) %>%
    rename(geo = state_abbrev)
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_boot.csv')) %>%
    rename(geo = state_abbrev)
  
  if(params$do_12mo) {
    
    sib_asdrs_12mo <- read_csv(file.path(out_dir, 
                                         'sib_12mo_design_asdrs.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_probs_12mo <- read_csv(file.path(out_dir, 
                                    'sib_12mo_design_probs.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_asdrs_boot_12mo <- read_csv(file.path(out_dir, 
                                         'sib_12mo_design_asdrs_boot.csv')) %>%
      rename(geo = state_abbrev)
    
    sib_probs_boot_12mo <- read_csv(file.path(out_dir, 
                                              'sib_12mo_design_probs_boot.csv')) %>%
      rename(geo = state_abbrev)
  
  }

} else if (geo_name == 'region') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs_region.csv')) %>%
    rename(geo = region)
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs_region.csv')) %>%
    rename(geo = region)
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_region_boot.csv')) %>%
    rename(geo = region)
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_region_boot.csv')) %>%
    rename(geo = region)
  
} else if (geo_name == 'national') {
  
  sib_asdrs <- read_csv(file.path(out_dir, 
                                  'sib_design_asdrs_national.csv')) %>%
    mutate(geo = 'national')
  
  sib_probs <- read_csv(file.path(out_dir, 
                                  'sib_design_probs_national.csv')) %>%
    mutate(geo = 'national')
  
  sib_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_asdrs_national_boot.csv')) %>%
    mutate(geo = 'national')
  
  sib_probs_boot <- read_csv(file.path(out_dir, 
                                       'sib_design_probs_national_boot.csv')) %>%
    mutate(geo = 'national')
  
}
```

Load network estimates

```{r}
if(geo_name == 'city') {
  
  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs.csv')) %>%
    rename(geo = state_abbrev)
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs.csv')) %>%
    rename(geo = state_abbrev)
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_boot.csv')) %>% 
    mutate(method='net_design') %>%
    rename(geo = state_abbrev)
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_boot.csv')) %>% 
    mutate(method='net_design') %>%
    rename(geo = state_abbrev,
           q.47.18 = q.47.18.mean)
  
} else if (geo_name == 'region') {

  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs_region.csv')) %>%
    rename(geo = region)
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs_region.csv')) %>%
    rename(geo = region)
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_region_boot.csv')) %>%
    mutate(method='net_design') %>%
    rename(geo = region)
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_region_boot.csv')) %>%
    mutate(method='net_design') %>%
    rename(geo = region,
           q.47.18 = q.47.18.mean)

} else if (geo_name == 'national') {
  
  net_asdrs <- read_csv(file.path(out_dir, 
                                  'net_design_asdrs_national.csv')) %>%
    mutate(geo = 'national')
  
  net_probs <- read_csv(file.path(out_dir, 
                                  'net_design_probs_national.csv')) %>%
    mutate(geo = 'national')
  
  net_asdrs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_asdrs_national_boot.csv')) %>%
    mutate(method='net_design') %>%
    mutate(geo = 'national')
  
  net_probs_boot <- read_csv(file.path(out_dir, 
                                       'net_design_probs_national_boot.csv')) %>%
    mutate(method='net_design') %>%
    mutate(geo = 'national') %>%
    rename(q.47.18 = q.47.18.mean)
  
}
```

Load estimated VR completeness

```{r}
if(geo_name == 'city') {
  ibge_vr_completeness <- read_csv(file.path(out_dir, 
                                             'vr_completeness_estimates.csv')) %>%
    rename(geo = state_abbrev)
}
```

Load city info

```{r}
city.dat <- read_csv(file.path(data_dir, "cities.csv"))
```



## Assemble the different results in one place

```{r}
est_asdrs <- bind_rows(sib_asdrs,
                       net_asdrs) %>%
  filter(agegp10 != '[65,75)') %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_asdrs_boot <- bind_rows(sib_asdrs_boot,
                            net_asdrs_boot) %>%
  filter(agegp10 != '[65,75)') %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_probs <- bind_rows(sib_probs,
                       net_probs) %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))

est_probs_boot <- bind_rows(sib_probs_boot,
                            net_probs_boot) %>%
  mutate(method = recode(method,
                         'sib_design'='Sibling',
                         'net_design'='Network')) %>%
  mutate(sex = recode(sex,
                      'male'='Male',
                      'female'='Female'))
```

Assemble 12 mo sib results too

```{r}
if(params$do_12mo) {
  est_asdrs_with12mo <- bind_rows(sib_asdrs,
                         sib_asdrs_12mo %>% mutate(method = 'Sibling12mo'),
                         net_asdrs) %>%
    filter(agegp10 != '[65,75)') %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_asdrs_boot_with12mo <- bind_rows(sib_asdrs_boot,
                              sib_asdrs_boot_12mo %>% mutate(method = 'Sibling12mo'),
                              net_asdrs_boot) %>%
    filter(agegp10 != '[65,75)') %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_probs_with12mo <- bind_rows(sib_probs,
                         sib_probs_12mo %>% mutate(method = 'Sibling12mo'),
                         net_probs) %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))
  
  est_probs_boot_with12mo <- bind_rows(sib_probs_boot,
                              sib_probs_boot_12mo %>% mutate(method = 'Sibling12mo'),
                              net_probs_boot) %>%
    mutate(method = recode(method,
                           'sib_design'='Sibling',
                           'net_design'='Network')) %>%
    mutate(sex = recode(sex,
                        'male'='Male',
                        'female'='Female'))  
}
```

# Summarize estimates

```{r}
# helper: calculate finite population variance
# of the values in some vector x
fp.var <- function(x) {
  return(mean((x - mean(x))^2))
}

# helper: jackknife variance estimate formula
# see, eg, the Efron book
# if x is a vector of jackknife (leave-one-out)
# variance estimates, this function combines them into
# an overall variance estimate
jack.var <- function(x) {
  P <- length(x)
  return( ((P-1)/P)*sum((x - mean(x))^2))
}
```

## Quantitative summaries

MSE on natural scale

```{r}
calc_errors <- function(df, ci = TRUE) {
  res <- df %>%
    mutate(delta = 1000*(post_mean_asdr - gs_asdr),
           delta2 = delta*delta,
           ## NB: delta_rel is the absolute relative error
           ##     and delta_rel_notabs is the relative error w/out taking absolute value
           delta_rel = abs(delta)/(1000*gs_asdr),
           delta_rel_notabs = delta/(1000*gs_asdr))
  if(ci) {
    res <- res %>%
      mutate(ci_covered = as.numeric(gs_asdr >= post_ci_low_asdr & gs_asdr <= post_ci_high_asdr))
  }
  
  return(res)
}

calc_errors_probs <- function(df, ci = TRUE) {
  res <- df %>%
    mutate(delta = post_mean_q - gs_prob,
           delta2 = delta*delta,
           delta_rel = abs(delta)/gs_prob,
           delta_rel_notabs = delta/gs_prob)
  if(ci) {
  res <- res %>% mutate(ci_covered = as.numeric(gs_prob >= post_ci_low_q & gs_prob <= post_ci_high_q))
  }
  return(res)
}
```

```{r}
comp_asdrs <- est_asdrs %>%
  left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
  calc_errors()

comp_asdrs_boot <- est_asdrs_boot %>%
  left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
  calc_errors(ci=FALSE)


comp_asdrs_wide_boot <- comp_asdrs_boot %>%
  select(-gs_asdr, -post_mean_asdr) %>%
  pivot_wider(names_from=method, values_from=c(delta, delta2, delta_rel, delta_rel_notabs)) %>%
  mutate(delta2.n.minus.s = delta2_Network - delta2_Sibling,
         delta_rel.n.minus.s = delta_rel_Network - delta_rel_Sibling)

comp_probs <- est_probs %>%
  left_join(gs_probs %>% dplyr::rename(gs_prob=q.47.18)) %>%
  calc_errors_probs()

comp_probs_boot <- est_probs_boot %>%
  dplyr::rename(post_mean_q = q.47.18) %>%
  left_join(gs_probs %>% dplyr::rename(gs_prob=q.47.18)) %>%
  calc_errors_probs(ci=FALSE)


comp_probs_wide_boot <- comp_probs_boot %>%
  select(-gs_prob, -post_mean_q, -time.period) %>%
  pivot_wider(names_from=method, values_from=c(delta, delta2, delta_rel, delta_rel_notabs)) %>%
  mutate(delta2.n.minus.s = delta2_Network - delta2_Sibling,
         delta_rel.n.minus.s = delta_rel_Network - delta_rel_Sibling)
```

Errors for 12mo sib ests

```{r}
if(params$do_12mo) {
  
  comp_asdrs_with12mo <- est_asdrs_with12mo %>%
    left_join(gs_asdrs %>% dplyr::rename(gs_asdr=asdr)) %>%
    calc_errors()
  
  # quick table comparing squared error for net / sib / sib 12mo
  errs_with_12mo <- comp_asdrs_with12mo %>%
    group_by(method) %>%
    summarize(mean_delta2 = mean(delta2),
              mean_delta_rel = mean(delta_rel))
  
  write_csv(errs_with_12mo,
            file.path(comp_out_dir, "avg_errs_with_sib12mo.csv"))
  saveRDS(errs_with_12mo,
            file.path(comp_out_dir, "avg_errs_with_sib12mo.rds"))
  
  errs_with_12mo
}
```

## Plots related to ASDR estimates

### Plot directly comparing estimated ASDRs from two methods

```{r plot-compare-ests}
direct_comp_est_asdrs <- 
  est_asdrs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'agegp10', 'geo'),
                       values_from=c('post_mean_asdr'),
                       names_from=c('method')) 

cur_range <- range(log(direct_comp_est_asdrs$Network),
                   log(direct_comp_est_asdrs$Sibling),
                   finite=TRUE)

alpha.val <- .6

# logged
direct_plot_logged <-  direct_comp_est_asdrs %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Network), 
                 y=log(Sibling),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling death rate est.)") +
  xlab("log(Network death rate est.)") +
  age_scale_color +
  theme_bw()

# NB: this is used in paper
saveRDS(direct_plot_logged, file.path(comp_out_dir, "direct_asdr_logged.rds"))
ggsave(filename=file.path(comp_out_dir, "direct_asdr_logged.pdf"),
       plot=direct_plot_logged,
       height=3.5,
       width=3.5)
direct_plot_logged

```


### Scatter plot with all ASDR estimates compared to VR, panel for each method

```{r}
method_facet_names <- c('Sibling' = 'Sibling Estimates',
                        'Network' = 'Network Estimates')

asdr_point_scatter_df <- est_asdrs %>%
  left_join(gs_asdrs) %>% 
  mutate(method = dplyr::recode(method, !!!method_facet_names))

cur_range <- range(c(asdr_point_scatter_df$post_mean_asdr,
                     asdr_point_scatter_df$asdr),
                   finite = TRUE)

asdr_point_scatter <- asdr_point_scatter_df %>%
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_abline(intercept=0, slope=1) +
  #geom_pointrange(aes(x=asdr, 
  geom_point(aes(x=asdr, 
                      y=post_mean_asdr, 
                      #ymin=post_ci_low_asdr,
                      #ymax=post_ci_high_asdr,
                      color=agegp10,
                      shape=sex),
                  alpha=.5) +
                  #size=rel(rel.point.size),
                  #stroke=point.stroke) +
  xlim(cur_range) + ylim(cur_range) +
  scale_x_log10() + 
  scale_y_log10() +
  facet_grid(~ method) +
  ylab("log(Estimated age-specific death rate)") +
  xlab("log(VR age-specific death rate)") +
  guides(color=guide_legend(title='Age', override.aes=list(alpha=1)),
         shape=guide_legend(title='', override.aes=list(alpha=1))) +
  coord_equal() +
  age_scale_color +
  NULL

# NB: this is used in paper
ggsave(filename=file.path(comp_out_dir, "asdr_point_scatter_log.pdf"),
       plot=asdr_point_scatter,
       height=4,
       width=6)
saveRDS(asdr_point_scatter, 
        file.path(comp_out_dir, "asdr_point_scatter_log.rds"))

asdr_point_scatter
```

### Plot that has a matrix of VR/Sibling/Network ests

```{r splom-sib-net-vr}
direct_comp_all_asdrs_df <- 
  est_asdrs %>%
    bind_rows(gs_asdrs %>% rename(post_mean_asdr=asdr) %>% mutate(method='VR')) %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'agegp10', 'geo'),
                       values_from=c('post_mean_asdr'),
                       names_from=c('method')) 

cur_range <- with(direct_comp_all_asdrs_df,
                  range(log(Sibling),
                        log(Network),
                        log(VR),
                        finite=TRUE))


alpha.val <- 0.6

splom_sn <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Sibling), 
                 y=log(Network),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  xlab("log(Sibling death rate est.)") +
  ylab("log(Network death rate est.)") +
  ggtitle("A") +
  age_scale_color +
  theme_bw() 



splom_vn <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(VR), 
                 y=log(Network),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Network death rate est.)") +
  xlab("log(VR death rate)") +
  ggtitle("B") +
  age_scale_color +
  theme_bw() 

splom_vs <- direct_comp_all_asdrs_df %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(VR), 
                 y=log(Sibling),
                 color=agegp10,
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(color=guide_legend(override.aes=list(alpha=1),
                            title='Age'),
         shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling death rate est.)") +
  xlab("log(VR death rate)") +
  ggtitle("C") +
  age_scale_color +
  theme_bw() 


splom_all <- splom_sn + 
             splom_vn +
             guide_area() +
             splom_vs + 
  plot_layout(guides='collect', nrow=2, byrow=TRUE)

meta_layout <- "
#cccddd
aeeefff
aeeefff
bggghhh
bggghhh
"

row1_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Network))', 
                                  angle=90,
                                  parse=TRUE) +  theme_void()
row2_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Sibling))', 
                                  angle=90,
                                  parse=TRUE) + theme_void()
col1_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(Sibling))',
                                  parse=TRUE) + theme_void()
col2_title <- ggplot() + annotate(geom='text', 
                                  x=1,y=1, 
                                  label='bold(underline(VR))',
                                  parse=TRUE) + theme_void()

plotlist <- list(a=row1_title,
                 b=row2_title,
                 c=col1_title,
                 d=col2_title,
                 e=splom_sn,
                 f=splom_vn,
                 g=guide_area(),
                 h=splom_vs)
  
final_splom <- wrap_plots(
     plotlist,
     guides='collect',
     design=meta_layout,
     widths=c(2,10,10)) & 
  theme(legend.box='horizontal')
  #theme(legend.box='horizontal', legend.position='bottom')

fig_height <-7 
fig_width <- fig_height

saveRDS(final_splom, file.path(comp_out_dir, "splom_asdr.rds"))
ggsave(filename=file.path(comp_out_dir, "splom_asdr.pdf"),
       plot=final_splom,
       height=fig_height,
       width=fig_width)
ggsave(filename=file.path(comp_out_dir, "splom_asdr.png"),
       plot=final_splom,
       height=fig_height,
       width=fig_width)
final_splom

# the network/sib comparison alone
# scale saved figure by this amount
lone_fac <- 0.5
splom_sn_tosave <- splom_sn + ggtitle("")
saveRDS(splom_sn_tosave, file.path(comp_out_dir, "net_vs_sib_asdr.rds"))
ggsave(filename=file.path(comp_out_dir, "net_vs_sib_asdr.pdf"),
       plot=splom_sn_tosave,
       height=fig_height*lone_fac,
       width=fig_width*lone_fac)
ggsave(filename=file.path(comp_out_dir, "net_vs_sib_asdr.png"),
       plot=splom_sn_tosave,
       height=fig_height*lone_fac,
       width=fig_width*lone_fac)
final_splom


```


### Estimates from both sources + VR values by geo, one per page


```{r plot-asdrs-ref, fig.width=3.5, fig.height=10}

rel.point.size <- .3
point.stroke <- .2

asdr_point_plot <- 
  est_asdrs %>%
  left_join(gs_asdrs) %>% 
  group_by(sex, geo) %>%
  # order facets by state difficulty
  mutate(delta = post_mean_asdr - asdr,
         state_difficulty = sum(abs(delta))) %>%
  ungroup() %>%
  mutate(geo = as_factor(geo),
         geo = forcats::fct_reorder(geo, state_difficulty)) %>%
         #geo = drlib::reorder_within(geo, state_difficulty, sex)) %>%
  # end new 
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_pointrange(aes(x=agegp10, 
                      y=post_mean_asdr, 
                      ymin=post_ci_low_asdr,
                      ymax=post_ci_high_asdr,
                      color=method,
                      shape=method),
                  position=position_dodge(width=.5),
                  size=rel(rel.point.size),
                  stroke=point.stroke) +
  geom_point(aes(x=agegp10,
                 y=asdr,
                 color='Vital registration',
                 shape='Vital registration'),
             size=rel(rel.point.size),
             stroke=1) +
  ylab("Age-specific death rate") +
  xlab("") +
  theme(strip.background=element_rect(fill=NA)) +
  guides(color=guide_legend(title='Method', override.aes=list(linetype=c(1,1,0))),
  #guides(color=guide_legend(title='Method'),
         shape=guide_legend(title='Method')) +
  scale_shape_manual(values=c('Sibling'=shape_sib, 'Network'=shape_net, 'Vital registration'=shape_gs))+
  scale_color_manual(values=c('Sibling'=color_sib, 'Network'=color_net, 'Vital registration'=color_gs)) +
  theme(legend.position='bottom',
        legend.direction='horizontal')
   
asdr_point_plot_log_onepage <- asdr_point_plot + 
  facet_grid(geo ~ sex) +
  scale_y_log10()

ggsave(filename=file.path(comp_out_dir, "asdr_pointrange_log.pdf"),
       plot=asdr_point_plot_log_onepage,
       height=10,
       width=3.5)
knitr::plot_crop(file.path(comp_out_dir, "asdr_pointrange_log.pdf"))

asdr_point_plot_log_multipage <- asdr_point_plot + 
  facet_grid_paginate(geo ~ sex, 
                      ncol=3, nrow=3) +
  scale_y_log10()


pdf(file.path(comp_out_dir, "asdr_pointrange_log_multipage.pdf"), onefile = TRUE)
for (i in 1:n_pages(asdr_point_plot_log_multipage)) {
    tmp <- asdr_point_plot_log_multipage + 
    facet_grid_paginate(geo ~ sex, 
                        ncol=3, nrow=3,
                        page=i) +
    scale_y_log10() 
    print(tmp)
}
dev.off()
knitr::plot_crop(file.path(comp_out_dir, "asdr_pointrange_log_multipage.pdf"))

asdr_point_plot_log_onepage
```



### Correlations between different sets of estimates

Summarize relationship between sibling and network probability of death estimates with correlation matrix


```{r}
direct_comp_all_probs_df <- 
  est_probs %>%
    bind_rows(gs_probs %>% rename(post_mean_q = q.47.18) %>% mutate(method='VR')) %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 

cat("\n\nCorrelation between probabilities, not on log scale\n")
# not on log scale
print(
  cor(direct_comp_all_probs_df %>% 
           select(Sibling, Network, VR))
)
```

Summarize relationship between sibling and network death rate estimates with correlation matrix


```{r}

cat("\n\nCorrelation between ASDRs, not on log scale\n")
# not on log scale
print(
  cor(direct_comp_all_asdrs_df %>% 
                select(Sibling, Network, VR))
  )
cat("\n\n")

cat("\n\nCorrelation between log(ASDR)s, log(0) mapped to tiny value:\n")
# log scale, replace log(0) with log(1e-8)
print(cor(direct_comp_all_asdrs_df %>% 
      select(Sibling, Network, VR) %>% 
      mutate(across(everything(),log)) %>%
      mutate(Sibling = ifelse(! is.finite(Sibling), log(1e-8), Sibling))))
cat("\n\n")

cat("\n\nCorrelation between log(ASDR)s, dropping rows where sibling estimates are 0\n")
# log scale, drop rows where sibling ests are 0
print(cor(
  direct_comp_all_asdrs_df %>% 
      select(Sibling, Network, VR) %>% 
      mutate(across(everything(),log)) %>%
      #filter(if_all(everything(), ~ is.finite(.x)))
      filter_all(all_vars(is.finite(.)))  
    ))
```


## Plots related to probability estimates 



```{r}
direct_comp_est_probs <- 
  est_probs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 

cur_range <- range(log(direct_comp_est_probs$Network),
                   log(direct_comp_est_probs$Sibling),
                   finite=TRUE)

```

### Scatter plot comparing estimated probs to VR, one panel per method 

```{r}
method_facet_names <- c('Sibling' = 'Sibling Estimates',
                        'Network' = 'Network Estimates')

prob_point_scatter_df <- est_probs %>%
  left_join(gs_probs %>% select(geo, sex, q.47.18)) %>% 
  mutate(method = dplyr::recode(method, !!!method_facet_names))

cur_range <- range(c(prob_point_scatter_df$post_mean_q,
                     prob_point_scatter_df$q.47.18),
                   finite = TRUE)

prob_point_scatter <- prob_point_scatter_df %>%
  ggplot(.) +
  theme_bw(base_size=5) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=q.47.18, 
                 y=post_mean_q, 
                 shape=sex),
                 alpha=.5) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  facet_grid(~ method) +
  ylab("Estimated probability of adult death") +
  xlab("VR probability of adult death") +
  guides(shape=guide_legend(title='', override.aes=list(alpha=1))) +
  NULL

# NB: this is used in paper
ggsave(filename=file.path(comp_out_dir, "prob_point_scatter.pdf"),
       plot=prob_point_scatter,
       height=4,
       width=6)
saveRDS(prob_point_scatter, 
        file.path(comp_out_dir, "prob_point_scatter.rds"))

prob_point_scatter
```


```{r plot-compare-ests-probs}
direct_comp_est_probs <- 
  est_probs %>%
    select(-time.period) %>%
    tidyr::pivot_wider(id_cols=c('sex', 'geo'),
                       values_from=c('post_mean_q'),
                       names_from=c('method')) 
```


```{r}
cur_range <- range(log(direct_comp_est_probs$Network),
                   log(direct_comp_est_probs$Sibling),
                   finite=TRUE)

alpha.val <- .6 
  
# logged
direct_plot_probs_logged <-  direct_comp_est_probs %>%
  ggplot(.) +
  geom_abline(intercept=0, slope=1) +
  geom_point(aes(x=log(Network), 
                 y=log(Sibling),
                 shape=sex), 
             alpha=alpha.val) +
  coord_equal() +
  xlim(cur_range) + ylim(cur_range) +
  guides(shape=guide_legend(override.aes=list(alpha=1),
                            title='')) +
  ylab("log(Sibling prob. of death est.)") +
  xlab("log(Network prob. of death est.)") +
  theme_bw()

# NB: this is used in paper
saveRDS(direct_plot_probs_logged, file.path(comp_out_dir, "direct_probs_logged.rds"))
ggsave(filename=file.path(comp_out_dir, "direct_probs_logged.pdf"),
       plot=direct_plot_probs_logged,
       height=3.5,
       width=3.5)
direct_plot_probs_logged

```



TODO - for all of these

-- do we want to switch to JAB estimates of MSEs?
-- what about regional and national analyses?


# Summaries of estimated sampling variation

## Minimum detectable effects

```{r}
##
## se - standard error for difference in two means
mde_onesided <- function(se, alpha=.05, beta=.2) {
  return(se * (qnorm(1-(alpha/2)) - qnorm(beta)))  
}

mde_asdrs <- est_asdrs %>% 
  group_by(method, agegp10, sex, time.period) %>% 
  summarize(mean_se = mean(post_sd_asdr), 
            mean_asdr=mean(post_mean_asdr)) %>% 
  mutate(cv_asdr = mean_se/mean_asdr, 
         ## NB: if two estimates both have std err sigma and are independent
         ##     then their difference will have std err sqrt(2)*sigma
         mde = mde_onesided((sqrt(2)*mean_se))) %>%
  mutate(rel_mde = mde / mean_asdr)

mde_probs <- est_probs %>% 
  group_by(method, sex, time.period) %>% 
  summarize(mean_se = mean(post_sd_q), 
            mean_prob = mean(post_mean_q)) %>% 
  mutate(cv_prob = mean_se/mean_prob, 
         ## NB: if two estimates both have std err sigma and are independent
         ##     then their difference will have std err sqrt(2)*sigma
         mde = mde_onesided(sqrt(2)*(mean_se))) %>%
  mutate(rel_mde = mde / mean_prob)

mde_asdrs
mde_probs
```


## CI width 

CI width for asdrs

```{r}
est_asdrs_ci_width <- est_asdrs %>%
  mutate(ci_width = post_ci_high_asdr - post_ci_low_asdr,
         rel_ci_width = ci_width / post_mean_asdr) %>%
  select(method, geo, agegp10, sex, ci_width, rel_ci_width) %>%
  pivot_wider(values_from = c('ci_width', 'rel_ci_width'),
              names_from = 'method',
              names_glue = "{.value}_{tolower(method)}") %>%
  # don't count cases w/ 0 deaths
  filter(ci_width_sibling != 0, ci_width_network != 0) %>%
  mutate(sib_over_net_ci_width = ci_width_sibling / ci_width_network,
         sib_over_net_rel_ci_width = rel_ci_width_sibling / rel_ci_width_network)
```


CI width for probabilities 

```{r}
est_probs_ci_width <- est_probs %>%
  mutate(ci_width = post_ci_high_q - post_ci_low_q,
         rel_ci_width = ci_width / post_mean_q) %>%
  select(method, geo, sex, ci_width, rel_ci_width) %>%
  pivot_wider(values_from = c('ci_width', 'rel_ci_width'),
              names_from = 'method',
              names_glue = "{.value}_{tolower(method)}") %>%
  # don't count cases w/ 0 deaths
  filter(ci_width_sibling != 0, ci_width_network != 0) %>%
  mutate(sib_over_net_ci_width = ci_width_sibling / ci_width_network,
         sib_over_net_rel_ci_width = rel_ci_width_sibling / rel_ci_width_network)
```

Save a dataframe with the CI properties

```{r}
# NB: this is used

all_ci_widths <-
  bind_rows(est_asdrs_ci_width %>% 
              mutate(qoi = 'asdr'),
            est_probs_ci_width %>% 
              mutate(qoi = 'prob')) %>%
  group_by(qoi) %>%
  summarize(mean_ci_width_sibling = mean(ci_width_sibling),
            mean_ci_width_network = mean(ci_width_network),
            avg_sibci_over_netci = mean(sib_over_net_ci_width),
            pct_over_1 = 100*mean(sib_over_net_ci_width > 1),
            # same quantities for relative CI
            mean_rel_ci_width_sibling = mean(rel_ci_width_sibling),
            mean_rel_ci_width_network = mean(rel_ci_width_network),
            avg_rel_sibci_over_netci = mean(sib_over_net_rel_ci_width),
            pct_rel_over_1 = 100*mean(sib_over_net_rel_ci_width > 1))

saveRDS(all_ci_widths,
        file=file.path(comp_out_dir, "ci_width.rds"))

all_ci_widths
```

# Point estimates of Bias/MSE/Var

These get calculated for each method/city/age/sex

```{r bvm-estimates}
asdr_properties_point_estimates <- comp_asdrs_boot %>%
  group_by(geo, sex, agegp10, method) %>%
  summarize( est_bias = mean(post_mean_asdr) - gs_asdr[1],
             est_mse = mean( (post_mean_asdr - gs_asdr[1])^2 ),
             est_mare = mean( abs(post_mean_asdr - gs_asdr[1])/gs_asdr[1]),
             est_var = fp.var(post_mean_asdr),
             est_mean = mean(post_mean_asdr)) %>%
  mutate(est_rmse = sqrt(est_mse)) %>%
  mutate(qty = 'asdr')

prob_properties_point_estimates <- comp_probs_boot %>%
  group_by(geo, sex, method) %>%
  summarize( est_bias = mean(post_mean_q) - gs_prob[1],
             est_mse = mean( (post_mean_q - gs_prob[1])^2 ),
             est_mare = mean( abs(post_mean_q - gs_prob[1])/gs_prob[1]),
             est_var = fp.var(post_mean_q),
             est_mean = mean(post_mean_q)) %>%
  mutate(est_rmse = sqrt(est_mse)) %>%
  mutate(qty = 'prob')
```

# Use JAB to calculate uncertainty in Bias/Variance/MSE


## Load the cluster counts associated w/ our bootstrap resamples

```{r read-cc-data}
survey_data_dir <- file.path(data_dir, 'survey')

cc_file <- "bootstrap_cc_jab10k.rds"
  
boot.cc <- readRDS(file.path(survey_data_dir, cc_file))
```

```{r}
if (geo_name == 'city') {
  
  boot.cc <- boot.cc %>% mutate(geo = state_abbrev)
  
} else if (geo_name == 'region') {
  # join regions onto boot.cc; call them geo
  boot.cc <- boot.cc %>%
    left_join(city.dat %>% select(state_abbrev, region)) %>%
    mutate(geo = region)
  
} else if (geo_name == 'national') {
  
  boot.cc <- boot.cc %>% mutate(geo = 'national')
  
}
```



*Algorithm*:

> for each city/geographical unit c 
>   for each cluster i from 1 to P_c
>     pick out bootstrap reps that don't include the cluster, B(c,-i)
>     calculate \widehat{\E}[B(c,-i)], the average estimate over B(c,-i)
>     calculate \widehat{\V}[B(c,-i)], the variance of estimates over B(c,-i)
>   calculate variance across the variance estimates (\widehat{\V}[B(c,-1)], \dots, \widehat{V}[B(c,-P_c)])

This takes ~20 seconds on my fancy laptop

```{r jab-indexes}
tic("Getting jackknife after bootstrap (JAB) indexes")
# this creates a list with one entry for each PSU
# that maps the PSU to the bootstrap indices that can be used for
# the hold-one-out jackknife after bootstrap calculation based on that PSU
jab_indexes <- 
  # NB: we assume that the columns are in order
  #  boot_rep_1, boot_rep_2, ...
  boot.cc %>%
  select(starts_with('boot_rep')) %>%
  transpose(.names = boot.cc$cb_code) %>%
  # convert number of times each PSU was included in the bootstrap resample
  # into an indicator with value 
  #  ... 1 if PSU was not included (so can be used in JAB calculation)
  #  ... 0 otherwise
  map(., ~ which(unlist(.x, use.names=FALSE) == 0))

# dataframe with cols
#   state_abbrev / geo
#   cb_code
#   jab_indexes - a list column; the entry is the bootstrap reps to use for JAB calculations
#   n_jab - the number of bootstrap resamples that did not have the PSU (and thus that can be used for JAB calculations)
jab_df <- tibble(
  cb_code = names(jab_indexes),
  jab_indexes = jab_indexes
  ) %>%
  left_join(
    #boot.cc %>% select(state_abbrev, cb_code)
    boot.cc %>% select(geo, cb_code)
  ) %>%
  mutate(n_jab = map_dbl(jab_indexes, ~ length(.x)))
toc()
```


## Calculate the leave-one-PSU-out (LOPO) estimates 

This takes about 8.5 minutes on my fancy laptop...

```{r leave-one-psu-out-estimates}
tic("Calculating leave-one PSU out estimates to use with jackknife after bootstrap")
lopo_ests <- jab_df %>%
  mutate(
    # leave one psu out ests
    lopo_ests = map2(jab_indexes, 
                     geo,
                     # this function takes a list of bootstrap indexes and
                     # calculates summaries of all of the estimates based
                     # on those indexes
                     function(jab_boot_indexes, cur_geo) {
                        cur_res <- comp_asdrs_boot %>%
                          filter(geo == cur_geo) %>%
                          # filter to boot indexes to be used for the hold-one-out calculations
                          # based on this index
                          filter(boot_idx %in% jab_boot_indexes) %>%
                          group_by(geo,sex,agegp10,method) %>%
                          summarize(n_jab_check = n(),
                                    # fp.var is our custom function that has n in the denom instead of (n-1)
                                    var_asdr_lopo = fp.var(post_mean_asdr),
                                    mean_asdr_lopo = mean(post_mean_asdr),
                                    bias_asdr_lopo = mean(post_mean_asdr - gs_asdr),
                                    mse_asdr_lopo = mean((post_mean_asdr - gs_asdr)^2),
                                    mare_asdr_lopo = mean( abs(post_mean_asdr - gs_asdr) / gs_asdr),
                                    .groups = "drop") %>%
                          mutate(rmse_asdr_lopo = sqrt(mse_asdr_lopo))
                        
                        return(cur_res)
                       
                     }))
toc()

tic("Calculating leave-one PSU out estimates of probabilities to use with jackknife after bootstrap")
lopo_prob_ests <- jab_df %>%
  mutate(
    # leave one psu out ests
    lopo_ests = map2(jab_indexes, 
                     geo,
                     # this function takes a list of bootstrap indexes and
                     # calculates summaries of all of the estimates based
                     # on those indexes
                     function(jab_boot_indexes, cur_geo) {
                        cur_res <- comp_probs_boot %>%
                          filter(geo == cur_geo) %>%
                          # filter to boot indexes to be used for the hold-one-out calculations
                          # based on this index
                          filter(boot_idx %in% jab_boot_indexes) %>%
                          group_by(geo,sex,method) %>%
                          summarize(n_jab_check = n(),
                                    # fp.var is our custom function that has n in the denom instead of (n-1)
                                    var_prob_lopo = fp.var(post_mean_q),
                                    mean_prob_lopo = mean(post_mean_q),
                                    bias_prob_lopo = mean(post_mean_q - gs_prob),
                                    mse_prob_lopo = mean((post_mean_q - gs_prob)^2),
                                    mare_prob_lopo = mean( abs(post_mean_q - gs_prob) / gs_prob),
                                    .groups = "drop") %>%
                          mutate(rmse_prob_lopo = sqrt(mse_prob_lopo))
                          
                        return(cur_res)
                       
                     }))
toc()
```

And wide version to calculate LOPO estimates for differences

```{r}
# this produces a tibble with one row for each
# PSU x age-sex group (so, 10 times the number of PSUs, \approx 41,000)
# note that, since each PSU is in exactly one city, each row here is
# a LOPO estimate that corresponds to a city/age/sex cell
lopo_ests_wide <- lopo_ests %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  select(-geo) %>%
  unnest(lopo_ests) %>%
  pivot_wider(names_from = 'method',
              values_from = c('rmse_asdr_lopo', 'mare_asdr_lopo',
                              'mse_asdr_lopo', 'bias_asdr_lopo',
                              'mean_asdr_lopo', 'var_asdr_lopo'),
              id_cols=c('cb_code', 'geo', 'agegp10', 'sex')) %>%
  pivot_longer(cols = contains('_lopo_'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*_lopo)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  mutate(qty = 'asdr')
```

```{r}
lopo_prob_ests_wide <- lopo_prob_ests %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  select(-geo) %>%
  unnest(lopo_ests) %>%
  pivot_wider(names_from = 'method',
              values_from = matches('prob_lopo'),
              id_cols=c('cb_code', 'geo', 'sex')) %>%
  pivot_longer(cols = contains('_lopo_'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*_lopo)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  mutate(qty = 'prob')
```

## Calculate properties of estimators at different levels of aggregation

### Age/Sex/Geo level

#### ASDRs

Use jackknife after bootstrap to estimate the properties of estimated death rate for each city/age/sex/method

```{r jab-estimates}
jab_asdr_ests <- lopo_ests_wide %>%
  #select(-jab_indexes) %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  #group_by(state_abbrev, geo, sex, agegp10, method) %>%
  group_by(geo, sex, agegp10) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mare_|^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  ungroup() %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}"))
```

```{r}
asdr_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_asdr_ests)

## long-form version
asdr_properties_long <- asdr_properties %>%
  pivot_longer(
    cols = contains(c("_Network", "_Sibling", "_diff")),
    names_to = c(".value", "method"),
    names_pattern = "(.*)_(Network|Sibling|diff)$"
  )
```


#### Probabilities

... and repeat for probabilities, one for each city/sex/method

```{r jab-estimates-prob}
jab_prob_ests <- lopo_prob_ests_wide %>%
  #select(-jab_indexes) %>%
  # geo is stored in lopo_ests, and we don't want to duplicate it
  #group_by(state_abbrev, geo, sex, agegp10, method) %>%
  group_by(geo, sex) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mare_|^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}"))
```

```{r}
prob_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_prob_ests)
```

### Geo level

#### ASDRs

```{r}
jab_geo_asdr_ests <- lopo_ests_wide %>%
  # aggregate LOPO estimates across age/sex groups within this city and PSU
  group_by(geo, cb_code) %>%
  summarize(# number of age/sex groups aggregated over (for debugging) 
            n_agesex_gps = n(),
            across(matches("^mare|^mean|^mse_|^rmse_|^bias_|^var_"),
                   mean,
                   # don't change the name of each column...
                   .names = "{.col}")) %>%
  group_by(geo) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mare_|^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```


```{r}
asdr_geo_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(geo, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_geo_asdr_ests)

asdr_geo_properties_long <- asdr_geo_properties %>%
  pivot_longer(
    cols = contains(c("_Network", "_Sibling", "_diff")),
    names_to = c(".value", "method"),
    names_pattern = "(.*)_(Network|Sibling|diff)$")
```

#### Probabilities

```{r}
jab_geo_prob_ests <- lopo_prob_ests_wide %>%
  # aggregate LOPO estimates across age/sex groups within this city and PSU
  group_by(geo, cb_code) %>%
  summarize(# number of age/sex groups aggregated over (for debugging) 
            n_agesex_gps = n(),
            across(matches("^mean|^mare_|^mse_|^rmse_|^bias_|^var_"),
                   mean,
                   # don't change the name of each column...
                   .names = "{.col}")) %>%
  group_by(geo) %>%
  summarize(# number of PSUs used in JAB calculation
            n_psu_jab = n(),
            across(matches("^mean"),
                   mean,
                   .names = "mean_jab_{.col}"),
            across(matches("^mare_|^mse_|^rmse_|^bias_|^var_"),
                   jack.var,
                   .names = "var_jab_{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'prob')
```

```{r}
prob_geo_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(geo, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_geo_prob_ests)
```


### Age/sex level

#### ASDRs

TODO - THINK ABOUT THIS
when aggregating up to an age across cities, need the (1/27)^2
when just calculating a mean, we do not need that

I think for each LOPO

```{r}
if (geo_name == 'city') {
  NUM_GEO_UNITS <- 27
} else if (geo_name == 'region') {
  NUM_GEO_UNITS <- 5
} else if (geo_name == 'national') {
  NUM_GEO_UNITS <- 1
}
  #summarize(across(starts_with('var'), 
  #                 ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
  #                 .names = "{.col}")) %>%
    
jab_agesex_asdr_ests <- jab_asdr_ests %>%
  group_by(agegp10, sex) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                           mean,
                           .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```


```{r}
asdr_agesex_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to age/sex level (by averaging across cities)
  group_by(agegp10, sex, method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  left_join(jab_agesex_asdr_ests) 
  # TODO - ADD SE?
```

#### NB: Probs not applicable 

N/A

### Total level 

#### ASDRs

```{r}
jab_tot_asdr_ests <- jab_geo_asdr_ests %>%
  group_by(1) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                   mean,
                   .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'asdr')
```

```{r}
asdr_tot_properties <- asdr_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  bind_cols(jab_tot_asdr_ests)
  # TODO - ADD SE?
```


#### Probs


```{r}
jab_tot_prob_ests <- jab_geo_prob_ests %>%
  group_by(1) %>%
  # sum variances across geo to get aggregate variance estimate
  # (and note we need to multiply by 1/C^2)
  summarize(across(matches("^mean_"),
                   mean,
                   .names = "{.col}"),
            across(matches("^var_"),
                   ~ ((1/NUM_GEO_UNITS)^2)*sum(.x) ,
                   .names = "{.col}")) %>%
  mutate(across(
    matches("^var_jab"),
    sqrt,
    .names = "{str_replace(.col, 'var_jab', 'se_jab')}")) %>%
  mutate(qty = 'prob')
```

```{r}
prob_tot_properties <- prob_properties_point_estimates %>%
  rename_with(~ paste0('point_', .x),
              starts_with('est_')) %>%
  # aggregate up to city level (by averaging across age/sex groups w/in city)
  group_by(method) %>%
  summarize(across(matches('point_'),
                   mean,
                   .names='{.col}')) %>%
  pivot_wider(names_from='method',
              values_from=starts_with('point_')) %>%
  pivot_longer(cols = contains('point_est'),
               names_to = c('metric', 'method'),
               names_pattern = "(.*)_(Network|Sibling)") %>%
  pivot_wider(names_from = method,
              values_from = value) %>%
  mutate(diff = Network - Sibling) %>%
  pivot_wider(names_from = metric,
              values_from = c(Network, Sibling, diff),
              names_glue = "{metric}_{.value}") %>%
  bind_cols(jab_tot_prob_ests)
```



## Plot the difference in error estimates in various ways


```{r}
# point estimate (not based on JAB)
rmse_geo_diff <- asdr_geo_properties %>%
  rename(est_rmse_diff = point_est_rmse_diff,
         est_mare_diff = point_est_mare_diff,
         se_rmse_diff = se_jab_rmse_asdr_lopo_diff,
         se_mare_diff = se_jab_mare_asdr_lopo_diff) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(c(1000*rmse_geo_diff$est_rmse_diff_ci_low,
                     1000*rmse_geo_diff$est_rmse_diff_ci_high))

if(geo_name == 'city') {
  annscale <- .8
  annxoff <- 0.2 
} else if (geo_name == 'region') {
  annscale <- 1.4 
  annxoff <- 0.2
} else if (geo_name == 'national') {
  annscale <- 1.8
  annxoff <- 0.2
}

diff_rmse_geo_plot <- rmse_geo_diff %>%
  ungroup() %>%
  mutate(geo = fct_reorder(geo, 
                           est_rmse_diff)) %>%
  ggplot(.) +
  geom_pointrange(aes(x = geo,
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(-6, 6)) +
  annotate(geom='text',
         label="<- Network is better ",
         #x='SE',
         x=annxoff,
         y=-biggestdiff*annscale,
         size=rel(3),
         color='red',
         angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=annxoff,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal() +
  coord_cartesian(clip = "off")

ggsave(filename=file.path(comp_out_dir, "diff_rmse_geo.pdf"),
       plot=diff_rmse_geo_plot,
       height=3.5,
       width=6)

diff_rmse_geo_plot
```



```{r}
# point estimate (not based on JAB)
rmse_age_diff <- asdr_agesex_properties %>%
  rename(est_rmse_diff = point_est_rmse_diff,
         est_mare_diff = point_est_mare_diff,
         se_rmse_diff = se_jab_rmse_asdr_lopo_diff,
         se_mare_diff = se_jab_mare_asdr_lopo_diff) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(c(1000*rmse_age_diff$est_rmse_diff_ci_low,
                     1000*rmse_age_diff$est_rmse_diff_ci_high))

if(geo_name == 'city') {
  annscale <- .8
  annxoff <- 0.2 
} else if (geo_name == 'region') {
  annscale <- 1.4 
  annxoff <- 0.2
} else if (geo_name == 'national') {
  annscale <- 1.8
  annxoff <- 0.2
}

diff_rmse_age_plot <- rmse_age_diff %>%
  ungroup() %>%
  ggplot(.) +
  geom_pointrange(aes(x = agegp10,
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high,
                      color=sex),
                  position=position_dodge(width=.2)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(-6, 6)) +
  annotate(geom='text',
         label="<- Network is better ",
         #x='SE',
         x=annxoff,
         y=-biggestdiff*annscale,
         size=rel(3),
         color='red',
         angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=annxoff,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal() +
  coord_cartesian(clip = "off")


ggsave(filename=file.path(comp_out_dir, "diff_rmse_age.pdf"),
       plot=diff_rmse_age_plot,
       height=3.5,
       width=6)

diff_rmse_age_plot
```


Get the total estimated difference in RMSE (averaged across all cities)

```{r}
# point estimate (not based on JAB)
rmse_tot_diff <- asdr_tot_properties %>%
  rename(est_rmse_diff = point_est_rmse_diff,
         est_mare_diff = point_est_mare_diff,
         se_rmse_diff = se_jab_rmse_asdr_lopo_diff,
         se_mare_diff = se_jab_mare_asdr_lopo_diff) %>%
  mutate(est_rmse_diff_ci_low = est_rmse_diff - 1.96*se_rmse_diff,
         est_rmse_diff_ci_high = est_rmse_diff + 1.96*se_rmse_diff)
```

```{r}
biggestdiff <- max(abs(c(1000*rmse_tot_diff$est_rmse_diff_ci_low, 
                     1000*rmse_tot_diff$est_rmse_diff_ci_high)))

annscale <- .5

diff_rmse_tot_plot <- rmse_tot_diff %>%
  ggplot(.) +
  geom_pointrange(aes(x = 'Average Overall RMSE Difference',
                      y = 1000*est_rmse_diff,
                      ymin = 1000*est_rmse_diff_ci_low,
                      ymax = 1000*est_rmse_diff_ci_high)) +
  geom_hline(yintercept=0) +
  xlab("") +
  ylab("Estimated RMSE Difference (x 1,000)\nNetwork RMSE - Sibling RMSE") +
  expand_limits(y = c(biggestdiff,-biggestdiff)) +
  annotate(geom='text',
           label="<- Network is better ",
           #x='SE',
           x=0.5,
           y=-biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=0.5,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme_minimal()


ggsave(filename=file.path(comp_out_dir, "diff_rmse_tot.pdf"),
       plot=diff_rmse_tot_plot,
       height=3.5,
       width=3.5)

diff_rmse_tot_plot
```


## Save results for plots

TODO - LEFT OFF HERE


OLD cols: boot_idx / err.n.minus.s / err.n / err.s / loss / qty / comparison_name / geo_name

TODO - LEFT OFF HERE
- want to save these files w/ columns qty, geo, loss
- re-run for vr / adj vr and for all geos
- then go to 06_plots and fix to work with these results
- ALSO revisit heatmaps and get margins to use these results

```{r}
asdr_tot_properties_tosave <-
  asdr_tot_properties %>%
  select(-`1`) %>%
  # make everything one long column
  pivot_longer(
    cols = -c(qty), 
    names_to = "full_name", 
    values_to = "value"
  ) %>%
  # 2. Extract components from the messy column names
  mutate(
    # Identify the group (at the end of the string)
    metric = case_when(
      str_detect(full_name, "Network$") ~ "Network",
      str_detect(full_name, "Sibling$") ~ "Sibling",
      str_detect(full_name, "diff$")    ~ "diff",
      TRUE ~ NA_character_
    ),
    # Identify the metric type (the column names you want)
    metric_type = case_when(
      str_detect(full_name, "^point_est") ~ "point_est",
      str_detect(full_name, "^mean_jab")  ~ "mean_jab",
      str_detect(full_name, "^var_jab")   ~ "var_jab",
      str_detect(full_name, "^se_jab")    ~ "se_jab",
      TRUE ~ NA_character_
    ),
    # Extract the loss function (the common property)
    loss = str_extract(full_name, "(rmse|mare|mse|bias|var|mean)(?=_asdr|_Network|_Sibling|_diff|$)")
  ) %>%
  # 3. Clean up: remove rows that didn't match (like the '1' column)
  filter(!is.na(metric), !is.na(loss)) %>%
  # 4. Pivot the metric_type column into actual columns
  select(qty, metric, loss, metric_type, value) %>%
  pivot_wider(
    names_from = metric_type, 
    values_from = value
  ) %>%
  filter(loss != 'mean') %>%
  select(-mean_jab) %>%
  mutate(geo_name = params$geo_name,
         comparison_name = params$comparison_name) %>%
  select(qty, metric, loss, geo_name, comparison_name, everything())

asdr_tot_properties_tosave
```

```{r}
prob_tot_properties_tosave <- 
  prob_tot_properties %>%
  select(-`1`) %>%
  # make everything one long column
  pivot_longer(
    cols = -c(qty), 
    names_to = "full_name", 
    values_to = "value"
  ) %>%
  # 2. Extract components from the messy column names
  mutate(
    # Identify the group (at the end of the string)
    metric = case_when(
      str_detect(full_name, "Network$") ~ "Network",
      str_detect(full_name, "Sibling$") ~ "Sibling",
      str_detect(full_name, "diff$")    ~ "diff",
      TRUE ~ NA_character_
    ),
    # Identify the metric type (the column names you want)
    metric_type = case_when(
      str_detect(full_name, "^point_est") ~ "point_est",
      str_detect(full_name, "^mean_jab")  ~ "mean_jab",
      str_detect(full_name, "^var_jab")   ~ "var_jab",
      str_detect(full_name, "^se_jab")    ~ "se_jab",
      TRUE ~ NA_character_
    ),
    # Extract the loss function (the common property)
    loss = str_extract(full_name, "(rmse|mare|mse|bias|var|mean)(?=_prob|_Network|_Sibling|_diff|$)")
  ) %>%
  # 3. Clean up: remove rows that didn't match (like the '1' column)
  filter(!is.na(metric), !is.na(loss)) %>%
  # 4. Pivot the metric_type column into actual columns
  select(qty, metric, loss, metric_type, value) %>%
  pivot_wider(
    names_from = metric_type, 
    values_from = value
  ) %>%
  filter(loss != 'mean') %>%
  select(-mean_jab) %>%
  mutate(geo_name = params$geo_name,
         comparison_name = params$comparison_name) %>%
  select(qty, metric, loss, geo_name, comparison_name, everything())

```

```{r}
# err_diffs_jab.csv

err_diffs_jab <- bind_rows(
        asdr_tot_properties_tosave,
        prob_tot_properties_tosave
        ) %>%
  select(qty, geo_name, comparison_name, everything())

write_csv(err_diffs_jab,
          file.path(comp_out_dir, "err_diffs_jab.csv"))

# this file is used in 06_plots.Rmd
err_diffs_jab
```



# National and regional analyses ends here; rest is only for cities

```{r}
if(geo_name %in% c('national', 'region')) {
  toc()
  knitr::knit_exit()
}
```

# NEW PLOTS

### BEGIN DEBUG VAR IN VAR

```{r}
asdr_properties %>%
  filter(sex == 'Male', 
         agegp10 == '[55,65)') %>%
  ggplot(.) +
  geom_point(aes(x = geo,
                 y = se_jab_var_asdr_lopo_Network),
             color='blue') +
  geom_point(aes(x = geo,
                 y = se_jab_var_asdr_lopo_Sibling),
             color='orange') +
  xlab("") +
  ylab("JAB estimate in uncertainty\nfor variance estimate\nMales 55-64") +
  theme_minimal()
```

### Look at what's up with TO...

Average estimate from leave-one-PSU-out samples versus the point estimate (directly from survey responses) 
These line up really well

```{r}
asdr_properties %>%
  filter(sex == 'Male', 
         agegp10 == '[55,65)') %>%
  ggplot(.) +
  geom_text(aes(x = point_est_mean_Network,
                y = mean_jab_mean_asdr_lopo_Network,
                label = geo)) +
  geom_abline(intercept=0, slope=1) +
  tune::coord_obs_pred() +
  xlab("Point Estimate") +
  ylab("Average of LOPO point estimates") +
  theme_minimal()
```


```{r}
to_ests <- lopo_ests %>%
  select(-jab_indexes) %>%
  unnest(cols = c(lopo_ests), names_sep='_') %>%
  #filter(geo == 'TO')
  filter(geo == 'DF')
  #filter(geo == 'RJ')

to_ests %>%
  filter(lopo_ests_method == 'Network') %>%
  #filter(lopo_ests_method == 'Sibling') %>%
  filter(lopo_ests_sex == 'Male', lopo_ests_agegp10 == '[55,65)') %>%
  ggplot(.,
         aes(x = 1000*lopo_ests_mean_asdr_lopo)) +
  #geom_density(color='blue', alpha = .1) +
  geom_histogram(aes(y = after_stat(density)),
                 binwidth = .2) +
  facet_grid(lopo_ests_agegp10 ~ lopo_ests_sex) +
  xlab("LOPO Estimate for ASDR") +
  theme_minimal()
```
```{r}
to_ests %>%
  filter(lopo_ests_method == 'Network') %>%
  #filter(lopo_ests_method == 'Sibling') %>%
  filter(lopo_ests_sex == 'Male', lopo_ests_agegp10 == '[55,65)') %>%
  #filter(lopo_ests_sex == 'Female', lopo_ests_agegp10 == '[55,65)') %>%
  #filter(lopo_ests_agegp10 == '[55,65)') %>%
  ggplot(.) +
  geom_histogram(aes(x = lopo_ests_var_asdr_lopo)) +
  facet_grid(lopo_ests_agegp10 ~ lopo_ests_sex) +
  xlab("LOPO Estimate for Var(hat{ASDR})") +
  theme_minimal()
```

```{r}
to_ests %>%
  filter(lopo_ests_method == 'Network') %>%
  #filter(lopo_ests_method == 'Sibling') %>%
  filter(lopo_ests_sex == 'Male', lopo_ests_agegp10 == '[55,65)') %>%
  #filter(lopo_ests_sex == 'Female', lopo_ests_agegp10 == '[55,65)') %>%
  #filter(lopo_ests_agegp10 == '[55,65)') %>%
  ggplot(.) +
  geom_point(aes(x = lopo_ests_mean_asdr_lopo,
                 y = lopo_ests_var_asdr_lopo)) +
  facet_grid(lopo_ests_agegp10 ~ lopo_ests_sex) +
  xlab("LOPO Estimate for ASDR") +
  ylab("LOPO Estimate for Var(hat{ASDR})") +
  theme_minimal()
```



Look at bootstrap resamples - how much variation in the actual estimate?

TO -> sibling estimate for males [55,65) is always 0 -> no reported deaths

```{r}
tmp <-  comp_asdrs_boot %>%
  filter(agegp10 == '[55,65)', sex == 'Male') %>%
  filter(method == 'Network')
  #filter(method == 'Sibling')

tmp %>%
  ggplot(aes(x = 1000*post_mean_asdr)) +
  geom_histogram(binwidth=1) +
  xlim(-1,100) +
  xlab("Network Estimated ASDR (Bootstrap resamples)") +
  facet_wrap(~geo) +
  theme_minimal()
```
Recall that the sibling method has no reported deaths for males aged 55-65 (see below)

```{r}
tmp <-  comp_asdrs_boot %>%
  filter(agegp10 == '[55,65)', sex == 'Male') %>%
  filter(method == 'Sibling')

tmp %>%
  ggplot(aes(x = 1000*post_mean_asdr)) +
  geom_histogram(binwidth=1) +
  xlim(-1,100) +
  xlab("Sibling Estimated ASDR (Bootstrap resamples)") +
  facet_wrap(~geo) +
  theme_minimal()
```


... so, the issue is estimates that are exactly 0 
(presumably because there are few reported deaths and so when bootstrap resamples omit PSUs
 that have reported deaths, the estimate is 0)

```{r}
tmp %>%
  group_by(geo) %>%
  summarize(num_resamples_zero_estimate = sum(post_mean_asdr == 0))
```





### END DEBUG

```{r}
asdr_agesex_properties_long <- asdr_agesex_properties %>%
  pivot_longer(
    cols = contains(c("_Network", "_Sibling", "_diff")),
    names_to = c(".value", "method"),
    names_pattern = "(.*)_(Network|Sibling|diff)$"
  )
```


## MSE - Network, Sibling, Comparison

This is Fig 3 in our notes

```{r}

method_facet_names <- c('Sibling' = 'Sibling Estimates',
                        'Network' = 'Network Estimates',
                        'diff' = 'Difference: Network - Sibling')

loss_plot <- function(cur_qoi_var, 
                      cur_se_var, 
                      ylab_text,
                      df = asdr_agesex_properties_long) {
  
  plot_df <- df %>%
      mutate(cur_qoi = {{cur_qoi_var}},
             cur_se = {{cur_se_var}})

  fig_netsib <-
    plot_df %>%
      filter(method %in% c('Network', 'Sibling')) %>%
      mutate(method = dplyr::recode(method, !!!method_facet_names)) %>%
      ggplot(.) +
      geom_pointrange(aes(x = agegp10,
                          y = cur_qoi,
                          ymax = cur_qoi + (1.96*cur_se),
                          ymin = cur_qoi - (1.96*cur_se),
                          color = sex
                          ),
                          position = position_dodge(width=0.4)
                      ) +
      facet_grid(~ method) +
      xlab("") +
      ylab(ylab_text) +
      theme_minimal()
  
  fig_diff <-
    plot_df %>%
      filter(method %in% c('diff')) %>%
      mutate(method = dplyr::recode(method, !!!method_facet_names)) %>%
      ggplot(.) +
      geom_hline(yintercept = 0, color = 'grey') +
      geom_pointrange(aes(x = agegp10,
                          y = cur_qoi,
                          ymax = cur_qoi + (1.96*cur_se),
                          ymin = cur_qoi - (1.96*cur_se),
                          color = sex
                          ),
                          position = position_dodge(width=0.4)
                      ) +
      facet_grid(~ method) +
      xlab("") +
      ylab("") +
      theme_minimal()
  
  fig_all <- fig_netsib + fig_diff +
             plot_layout(widths = c(2,1),
                         guides = 'collect')
  return(fig_all)

}

fig_mse <- loss_plot(point_est_rmse, se_jab_rmse_asdr_lopo, 'Estimated RMSE')
fig_mse
```

```{r}
fig_var <- loss_plot(point_est_var, se_jab_var_asdr_lopo, 'Estimated variance')
fig_var
```

```{r}
fig_bias <- loss_plot(point_est_bias, se_jab_bias_asdr_lopo, 'Estimated bias')
fig_bias
```


# Maps / Geography

```{r}
# join in city names for titles
state.city.map <- city.dat %>% select(state_abbrev, region, state_name, city_name=municipio)
state.city.map <- state.city.map %>%
  mutate(title = paste0(city_name, " (", state_abbrev, ")")) %>%
  mutate(geo = state_abbrev)
  #mutate(title = paste0(city_name, ",\n", state_name))

#br_customgrid <- br_grid1 %>% 
br_customgrid <- br_states_grid1 %>% 
  select(-name) %>%
  left_join(state.city.map %>% select(code=state_abbrev, name=title))
```

## Summarize raw / realized errors by geography

All ests, by geography

TODO - I think we want to remove this soon

```{r calculate-errs-in-asdrs-by-geo, eval=FALSE}
comp_asdrs_bygeo <- comp_asdrs %>%
  group_by(method, geo) %>%
  summarize(geo_mse = mean(delta2),
            #geo_are = sum(abs(delta_rel))) 
            # this should be the mean, right?
            geo_are = mean(abs(delta_rel))) 

# difference in MSE (network - sibling)
comp_asdrs_bygeo_wide <- comp_asdrs_bygeo %>%
  select(-geo_are) %>%
  pivot_wider(names_from=method, values_from=geo_mse)  %>%
  mutate(n.minus.s = Network - Sibling)

# difference in ARE (network - sibling)
comp_rel_asdrs_bygeo_wide <- comp_asdrs_bygeo %>%
  select(-geo_mse) %>%
  pivot_wider(names_from=method, values_from=geo_are) %>%
  mutate(n.minus.s = Network - Sibling)


comp_asdrs_bygeoas <- comp_asdrs %>%
  group_by(method, geo, sex, agegp10) %>%
  summarize(geo_mse = mean(delta2),
            # this should be the mean, right?
            geo_are = mean(abs(delta_rel)),
            # not absolute relative error (so, can be negative)
            geo_re = mean(delta_rel_notabs)) %>%
  ungroup() %>%
  mutate(geo_rmse = sqrt(geo_mse))

# difference in MSE (network - sibling)
comp_asdrs_bygeoas_wide <- comp_asdrs_bygeoas %>%
  select(-geo_are, -geo_re, -geo_rmse) %>%
  pivot_wider(names_from=method, values_from=geo_mse)  %>%
  mutate(n.minus.s = Network - Sibling)

comp_asdrs_byas <- comp_asdrs %>%
  group_by(method, sex, agegp10) %>%
  summarize(as_mse = mean(delta2),
            as_are = mean(abs(delta_rel)),
            # not absolute relative error (so, can be negative)
            as_re = mean(delta_rel_notabs))  
```


## Plot the difference between the two methods against the estimated VR completeness

Plot the difference between the two methods (MSE) against the estimated completeness

```{r comp-errs-mse-vrcompleteness, fig.height=3.5, fig.width=3.5}
## NB: only have completeness at the state level...
if(geo_name == 'city') {

# difference in MSE by geography
#comp_df <- comp_asdrs_bygeo_wide %>%
#  select(geo, point_est_mse_diff = n.minus.s)
comp_df <- asdr_geo_properties %>%
  select(geo, point_est_mse_diff)

comp_df_withvr <- comp_df %>%
  left_join(ibge_vr_completeness %>%
              select(geo, ibge_est_vrcov = mean_sim_cov_pct))

biggestdiff <- max(abs(comp_df_withvr$point_est_mse_diff))
xrange <- c(-biggestdiff, biggestdiff)

## controls how far out annotations go
annscale <- .6

geo_err_mse_vr_comp <-
  comp_df_withvr %>%
        mutate(geo = fct_reorder(geo, point_est_mse_diff)) %>%
  ggplot(.) +
  geom_text(aes(y=point_est_mse_diff,
                x=ibge_est_vrcov,
                label=geo)) +
  #geom_vline(xintercept=0, color='dark grey') +
  #geom_point(aes(y=state_abbrev, x=n.minus.s)) +
  theme_minimal() +
  ylab("Network estimate MSE - Sibling estimate MSE") +
  xlab("Estimated VR completeness") +
  expand_limits(y=xrange) +
  annotate(geom='text',
           label="<- Network is better ",
           #x='SE',
           x=100,
           y=-biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  annotate(geom='text',
           label="Sibling is better ->",
           #x='SE',
           x=100,
           y=biggestdiff*annscale,
           size=rel(3),
           color='red',
           angle=90) +
  theme(axis.title.x=element_text(size=rel(.8))) +
  ## see
  ## https://stackoverflow.com/questions/12409960/ggplot2-annotate-outside-of-plot
  ## for how this helps plot not clip annotations
  coord_cartesian(clip='off') +
  NULL


ggsave(filename=file.path(comp_out_dir, "geo_err_summ_mse_vrsens.pdf"),
       plot=geo_err_mse_vr_comp,
       height=3.5,
       width=3.5)
knitr::plot_crop(file.path(comp_out_dir, "geo_err_summ_mse_vrsens.pdf"))

geo_err_mse_vr_comp

}
```
```{r}
asdr_properties_long <- asdr_properties %>%
  pivot_longer(
    cols = contains(c("_Network", "_Sibling", "_diff")),
    names_to = c(".value", "method"),
    names_pattern = "(.*)_(Network|Sibling|diff)$"
  )
```

## Hexgrid maps

Helper fn 

```{r city-method-mare-map, fig.height=4.5, fig.width=3}
  
#comp_df <- comp_rel_asdrs_bygeo_wide
  
##
## data - dataset to use, already filtered (so either males or females)
##        needs a column called 'geo'
## qoivar - the value to plot
## name - the label for the qoi
br_compare_choro_map <- function(data, 
                                 qoivar, 
                                 name, 
                                 title=NULL, 
                                 labels=TRUE, 
                                 fillscale=NULL,
                                 logfill=FALSE,
                                 hex=TRUE) {
    
  mapobj <- readRDS(file.path(out_dir, "brazil_map.rds"))
  
  # should we plot a hex map? or a political map?
  if(hex) {
    # hexmap
    if(geo_name == 'region') {
      basemap <- mapobj$hexmap_region
    } else {
      basemap <- mapobj$hexmap
    }
    # political map
  } else {
    basemap <- mapobj$map
  }
  
  if(geo_name == 'city') {
    mapraw <- basemap %>%
      mutate(geo = postal) 
  } else {
    mapraw <- basemap %>%
      mutate(geo = region) 
  }
  
  mapdat <- mapraw %>%
    left_join(data %>% rename(qoi = qoivar))
  
  capdat <- mapobj$capitals
  
  if(is.null(fillscale)) {
    # default fill scale
    plot_fill_scale <- scale_fill_distiller(name=name, type='div')
  } else {
    plot_fill_scale <- fillscale
  }
  
  if (logfill) {
    plot_fill_scale <- plot_fill_scale + scale_color_continuous(trans=log10)
  }
  

  # for removing the background from ggplots
  remove_background <- theme(panel.background = element_blank(),
            panel.border = element_blank(),
            panel.grid.major = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.y = element_blank(),
            axis.text.y = element_blank()) 
  
  cur_map <- 
    ggplot(data=mapdat) + 
      theme_bw(base_size=5) +
      geom_sf(aes(fill=qoi), 
              linetype='dotted', 
              alpha=.8) +
    plot_fill_scale +
    #log_scale_fill +
    remove_background  +
    xlab('') + ylab('') +
    theme(legend.position=c(.2,.3),
          legend.direction='vertical',
          legend.text=element_text(size=8),
          legend.title=element_text(size=8, face='bold')) +
    NULL
  
  if(labels) {
    cur_map <- cur_map +
      geom_sf(data=capdat) +
      geom_text_repel(data=capdat,
                      aes(x=lon, y=lat, 
                          label=glue::glue("{municipio} ({state_abbrev})")),
                      size=rel(3))
  }
  
  if(! is.null(title)) {
    cur_map <- cur_map + ggtitle(title)
  }
  
  return(cur_map)
}

# see 
# https://github.com/tidyverse/ggplot2/issues/1012
scale_fill_log10 <- function(...) {
  scale_fill_continuous(..., trans = scales::log10_trans())
}

# make maps for each age/sex group and assemble
# them into one figure
br_hexgrid_map <- function(qoivar,
                           qoiname,
                           scale_lims=NULL,
                           fillscale=NULL,
                           logfill=FALSE) {
  
  # TODO 
  if(! is.null(scale_lims)) {
    cur_lims <- scale_lims*1.05 
  } else {
    cur_lims <- NULL
  }
  
  if(logfill) {
    plot_logfill <- scale_fill_log10()
  } else {
    plot_logfill <- NULL
  }
  
  if(! is.null(fillscale)) {
    plot_fillscale <- fillscale
  } else {
    plot_fillscale <- scale_fill_distiller(name=qoiname, 
                                           palette = 'Spectral',
                                           limits=cur_lims,
                                           oob=scales::squish,
                                           type='div') 
  }
  
  #maps_indiv <- comp_asdrs_bygeoas %>%
  maps_indiv <- 
    # take asdr_properties, which is in wide format, and convert it into long
    # format
    asdr_properties_long %>%
    # we don't need diffs, just Network and Sibling
    filter(method != 'diff') %>%
    # and rmse should be multiplied by 1000 so it's comparable to death rates
    mutate(point_est_rmse = 1000 * point_est_rmse) %>%
    # the rest here is unchanged...
    group_by(sex, method, agegp10) %>%
    group_modify(function(cur_df, key) {
      
      cur_sex <- key$sex[1]
      cur_agegp10 <- key$agegp10[1]
      cur_method <- key$method[1]
      
      cur_map_errs <- br_compare_choro_map(cur_df,
                                           qoivar=qoivar,
                                           title=glue::glue('{cur_method}: {cur_sex}, {cur_agegp10}'),
                                           name=glue::glue('{cur_method} {qoiname}'),
                                           labels=FALSE,
                                           fillscale=plot_fillscale,
                                           hex=TRUE) +
        plot_logfill
      return(tibble(map_errs=list(cur_map_errs)))
      
    })
  
  layout <- "
  AF#KP
  BG#LQ
  CH#MR
  DI#NS
  EJ#OT
  "
  
  ppw <- 4 # plot panel width (relative)
  spw <- 1 # space panel width (relative)
  
  
  maps_array <- maps_indiv %>% 
    pull(map_errs) %>%
    wrap_plots(design=layout,
               widths=c(ppw, ppw, spw, ppw, ppw)) +
    plot_layout(guides='collect') &
    theme(legend.position='bottom',
          legend.direction='horizontal',
          plot.title=element_text(hjust=0.5)) 
  
  
  meta_layout <- "
  ##FF###MM##
  #NNSS#TTUU#
  APPPPPPPPPV
  BPPPPPPPPPW
  CPPPPPPPPPX
  DPPPPPPPPPY
  EPPPPPPPPPZ
  "
  
  final_maps <- wrap_plots(
     A=wrap_elements(grid::textGrob("18-24")), 
     B=wrap_elements(grid::textGrob("25-34")), 
     C=wrap_elements(grid::textGrob("35-44")), 
     D=wrap_elements(grid::textGrob("45-54")), 
     E=wrap_elements(grid::textGrob("55-64")), 
     V=wrap_elements(grid::textGrob("18-24")), 
     W=wrap_elements(grid::textGrob("25-34")), 
     X=wrap_elements(grid::textGrob("35-44")), 
     Y=wrap_elements(grid::textGrob("45-54")), 
     Z=wrap_elements(grid::textGrob("55-64")), 
     F=wrap_elements(grid::textGrob("Female")),
     M=wrap_elements(grid::textGrob("Male")),
     N=wrap_elements(grid::textGrob("Network")),
     T=wrap_elements(grid::textGrob("Network")),
     S=wrap_elements(grid::textGrob("Sibling")),
     U=wrap_elements(grid::textGrob("Sibling")),
     P=maps_array,
     design=meta_layout,
   heights=c(1,1,rep(6,5))) +
   plot_annotation(caption="Values outside of limits squished to limits.")
  
  return(final_maps)
}
```

Plot age/sex RMSE for estimates

```{r method_map_as_rmse}
#method_rmse_as_maps <- br_hexgrid_map(qoivar='geo_rmse',
method_rmse_as_maps <- br_hexgrid_map(qoivar='point_est_rmse',
                                      qoiname='RMSE',
                                      scale_lims=c(0,10))
      
saveRDS(method_rmse_as_maps, file.path(comp_out_dir, "method_rmse_agesex_map.rds"))
ggsave(filename=file.path(comp_out_dir, "method_rmse_agesex_map.pdf"),
       plot=method_rmse_as_maps,
       height=10,
       width=8)
ggsave(filename=file.path(comp_out_dir, "method_rmse_agesex_map.png"),
       plot=method_rmse_as_maps,
       height=10,
       width=8)

method_rmse_as_maps
```

## Summarize Geographical relationships with Moran's I

Helper function to calculate Moran's I

```{r}

calculate_moran_I <- function(qoi_df, 
                              qoi_var, 
                              alternative = 'two.sided',
                              # other args for spdep::moran.test
                              ...) {

  mapobj <- readRDS(file.path(out_dir, "brazil_map.rds"))
  
  if(geo_name == 'city') {
    mapraw <- mapobj$map %>%
      mutate(geo = postal) 
  } else {
    mapraw <- mapobj$map %>%
      mutate(geo = region) %>%
      group_by(geo) %>%
      summarize() %>%
      ungroup()
  }
  
  # see
  # https://mgimond.github.io/Spatial/spatial-autocorrelation-in-r.html
  neighbors <- spdep::poly2nb(mapraw) 
  neighbors_weight <- spdep::nb2listw(neighbors, style="W", zero.policy=TRUE)
  
  #comp_rel_asdrs_bygeo_wide,
  #qoivar='n.minus.s'
                                        
  mapdat <- mapraw %>%
    left_join(qoi_df %>% rename(qoi = all_of(qoi_var)))
  
  res <- spdep::moran.test(mapdat[['qoi']], 
                           listw=neighbors_weight,
                           alternative=alternative,
                           ...)
  
  res$moran_I <- round(res$estimate[1],2)
  res$p_value <- round(res$p.value, 2)
  res$desc <- glue::glue("Moran's I, p-value calculated based on {alternative}",
                         .envir = res)
    
  # rename 'method' slot, since we use that for something else
  res$moran_method <- res$method
  res$method <- NULL
  
  return(res)
}

# helper function to coerce results of Moran's I calculation
# to a tibble row
moran_I_to_tibble <- function(res, ...) {
  class(res) <- NULL
  res$estimate <- list(res$estimate)
  return(as_tibble_row(c(res, ...)))
}

```

### DEBUG

TODO LEFT OFF HERE

- why are moran's I results different? 
- should standardize RMSE on 1000 x MSE 
- check that heatmaps seem right, etc

```{r}
foo <- asdr_properties_point_estimates %>%
  select(geo, method, chk_value = est_rmse) %>%
  mutate(chk_value = 1000*chk_value) %>%
  group_by(geo) %>%
  summarize(chk_value = mean(chk_value))
```


```{r}
# I think these two should be pretty similar - but they seem not to be. Why?
old_moran_df <- 
  # NEW
  #asdr_geo_properties_long %>%
  #mutate(value = 1000*point_est_mse) %>% 
  # END NEW
  # OLD
  comp_asdrs_bygeoas_wide %>%
  rename(diff = 'n.minus.s') %>%
  pivot_longer(cols=c('Network', 'Sibling', 'diff'),
               names_to = 'method',
               values_to = 'value') %>%
  ungroup() %>%
  group_by(geo, method) %>%
  summarize(value = mean(value)) 

new_df <- 
  asdr_geo_properties_long %>%
  mutate(value = 1000*point_est_rmse)

tmp <- old_moran_df %>%
  rename_with(~ paste0('prev_', .x), value) %>%
  left_join(new_df) %>%
  left_join(foo)

tmp %>%
  ggplot(.) +
  #geom_point(aes(x = 1000*point_est_rmse, y=prev_value)) +
  #geom_point(aes(x = chk_value, y=1000*point_est_rmse)) +
  geom_point(aes(x = chk_value, y=prev_value)) +
  facet_wrap(~method) +
  tune::coord_obs_pred()

```


### Moran's I for MSE values

Calculate Moran's I for MSE values

```{r}
mse_moran_I <- 
  # NEW
  asdr_geo_properties_long %>%
  mutate(value = 1000*point_est_mse) %>% 
  # END NEW
  # OLD
  #comp_asdrs_bygeoas_wide %>%
  #rename(diff = 'n.minus.s') %>%
  #pivot_longer(cols=c('Network', 'Sibling', 'diff'),
  #             names_to = 'method',
  #             values_to = 'value') %>%
  #ungroup() %>%
  #group_by(geo, method) %>%
  #summarize(value = mean(value)) %>%
  # END OLD
  group_by(method) %>%
  group_map(function(cur_df, key) {
    
    cur_method <- key$method[1]
    
    res <- calculate_moran_I(cur_df, 'value')
    
    res$sex <- 'both'
    res$agegp10 <- 'all'
    res$method <- cur_method
    
    return(res)
    
  })

spatial_res_mse <- map_dfr(mse_moran_I,
                           ~ moran_I_to_tibble(.x,
                                               qty = 'MSE'))
```

Calculate Moran's I for MSE values by age/sex group

```{r}
mse_as_moran_I <- 
  asdr_properties_long %>%
  mutate(value = point_est_rmse*1000) %>%
  ## OLD
  #comp_asdrs_bygeoas_wide %>%
  #rename(diff = 'n.minus.s') %>%
  #pivot_longer(cols=c('Network', 'Sibling', 'diff'),
  #             names_to = 'method',
  #             values_to = 'value') %>%
  ## END OLD
  ungroup() %>%
  group_by(sex, method, agegp10) %>%
  group_map(function(cur_df, key) {
    
    cur_sex <- key$sex[1]
    cur_agegp10 <- key$agegp10[1]
    cur_method <- key$method[1]
    
    res <- calculate_moran_I(cur_df, 'value')
    
    res$sex <- cur_sex
    res$agegp10 <- cur_agegp10
    res$method <- cur_method
    
    return(res)
    
  })

spatial_res_mse_as <- map_dfr(mse_as_moran_I,
                              ~ moran_I_to_tibble(.x,
                                                  qty = 'MSE'))
```

```{r}
moran_I_df <- bind_rows(spatial_res_mse,
                        spatial_res_mse_as)


write_csv(moran_I_df %>% unnest_wider(estimate) %>% arrange(p_value),
          file.path(comp_out_dir, "moran_I.csv"))
```

Moran's I values that are significant at $p=0.05$ level

```{r}
moran_I_df %>% filter(p_value < 0.05)
```

# Heatmaps showing error

```{r}
# see
# https://stackoverflow.com/questions/60016390/set-axes-limits-in-patchwork-when-combining-ggplot2-objects
apply_consistent_y_lims <- function(this_plot){
    num_plots <- length(this_plot$layers)
    y_lims <- lapply(1:num_plots, function(x) ggplot_build(this_plot[[x]])$layout$panel_scales_y[[1]]$range$range)
    min_y <- min(unlist(y_lims))
    max_y <- max(unlist(y_lims))
    this_plot & ylim(min_y, max_y)
}
```


```{r}
## NB: this fn assumes that the environment has
##   geo_err_diffs_summ ===>  asdr_geo_properties
##   agesex_err_diffs_summ ===> asdr_agesex_properties
##   geo_agesex_err_diffs_summ ====> asdr_properties

# err_metric -> mare_Network, rmse_Sibling, rmse_diff, etc...
err_breakdown_plot <- function(err_metric, 
                               err_metric_name, 
                               # asdr or prob
                               qty = 'asdr',
                               diff = FALSE) {
  # TEMP DEV 
  #err_metric <- 'net_mare'
  #err_metric <- 'mare_Network'
  #err_metric_name <- 'Network\nMARE'
  #qty <- 'asdr'
 
  err_metric_split <- str_split(err_metric, "_", simplify=TRUE) 
  loss_name <- err_metric_split[1,1]
  method_name <- err_metric_split[1,2]
  
  diff <- (method_name == 'diff')
  
  if (diff) {
    fill_scale <- scale_fill_gradient2(low='yellow', high='red', midpoint=0)
    vline <- geom_vline(xintercept = 0, color='grey')
    hline <- geom_hline(yintercept = 0, color='grey')
    symm_x <- lemon::scale_x_symmetric(mid=0)
  } else {
    fill_scale <- scale_fill_gradient(low='white', high='red')
    vline <- NULL
    hline <- NULL
    symm_x <- NULL
  }
  
  ## age-sex plot
  #as_plot <- agesex_err_diffs_summ %>%
  #  ## rename current error
  #  rename_with(~ str_replace(.x, err_metric, 'err'),
  #              .cols=starts_with(err_metric)) %>%
  as_plot <- asdr_agesex_properties %>%
    ## rename current error
    ## end up called err, err_ci_low, and err_ci_high
    mutate( err = .data[[ paste0('point_est_', err_metric) ]],
            se = .data[[ paste0('se_jab_', loss_name, '_', qty, '_lopo_', method_name)]]) %>%
    mutate(err_ci_low = err - 1.96*se,
           err_ci_high = err + 1.96*se) %>%
    #rename_with(~ str_replace(.x, err_metric, 'err'),
    #            .cols=starts_with(err_metric)) %>%
    ggplot(.) +
    geom_pointrange(aes(x=agegp10, 
                        ymin=err_ci_low,
                        ymax=err_ci_high,
                        y=err)) +
    facet_wrap(~ sex) +
    theme_minimal() +
    xlab("") +
    expand_limits(y = 0) +
    hline + 
    ylab(err_metric_name)

   #geo_err_diffs_summ_forplot <- geo_err_diffs_summ %>%
   geo_err_diffs_summ_forplot <- asdr_geo_properties %>%
    ## rename current error
    #rename_with(~ str_replace(.x, err_metric, 'err'),
    #            .cols=starts_with(err_metric)) %>%
    mutate( err = .data[[ paste0('point_est_', err_metric) ]],
            se = .data[[ paste0('se_jab_', loss_name, '_', qty, '_lopo_', method_name)]]) %>%
    mutate(err_ci_low = err - 1.96*se,
           err_ci_high = err + 1.96*se) %>%     
    ungroup() %>%
    mutate(geo = factor(geo)) %>%
    mutate(geo = fct_reorder(geo, err))
   
   geo_lev_order <- levels(geo_err_diffs_summ_forplot$geo)
   
   city_plot <- geo_err_diffs_summ_forplot %>%
     ggplot(.) +
     geom_pointrange(aes(x=err, 
                         xmin=err_ci_low,
                         xmax=err_ci_high,
                         y=geo)) +
     theme_minimal() +
     xlab(err_metric_name) +
     expand_limits(x = 0) +
     symm_x +
     vline +
     ylab("")
   
   ## summarize errors across bootstrap reps within each city/age/sex gp
   #hm <- geo_agesex_err_diffs_summ %>%
   # ## rename current error
   # rename_with(~ str_replace(.x, err_metric, 'err'),
   #             .cols=starts_with(err_metric)) %>%
   hm <- asdr_properties %>%
     mutate( err = .data[[ paste0('point_est_', err_metric) ]],
             se = .data[[ paste0('se_jab_', loss_name, '_', qty, '_lopo_', method_name)]]) %>%
     ungroup() %>%
     mutate(geo = factor(geo)) %>%
     mutate(geo = fct_relevel(geo, geo_lev_order)) %>%
     ggplot(.) +
     geom_tile(aes(x=agegp10, y=geo, fill=err)) +
     facet_wrap(~ sex) +
     theme_minimal() +
     xlab("") +
     ylab("") +
     theme(legend.position = 'bottom') +
     fill_scale +
     expand_limits(fill = 0) +
     #coord_equal() +
     guides(fill = guide_colorbar(title = err_metric_name,
                                  title.position="top"))
     #scale_fill_gradient(low='black', high='red')   
  
  # 1 : heatmap
  # 2 : city agg errs
  # 3 : age-sex errs
  design <- "
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    111111111112222
    333333333334444
    333333333334444
    333333333334444
    333333333334444
  "
  #p1 <- (hm + ggtitle("City, Probability")) + 
  #      (city_plot + ggtitle("City, Age-specific death rate")) + 
  #      (as_plot + ggtitle("Region, Probability")) +
  test <- (hm + ggtitle("A")) + 
        (city_plot + ggtitle("B")) + 
        (as_plot + ggtitle("C")) +
        guide_area() +
    plot_layout(guides='collect', design=design)   
  
  return(test)
}

```


```{r}
# height / width for saved plots
pheight <- 10
pwidth <- 7.5
```


### MARE

Network MARE

```{r}
#err_breakdown_mare_net <- err_breakdown_plot('net_mare', 
err_breakdown_mare_net <- err_breakdown_plot('mare_Network', 
                                             'Network\nMARE',
                                             'asdr')

#saveRDS(err_breakdown_mare_net, 
#        file.path(comp_out_dir, "err_breakdown_mare_net.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_mare_net.pdf"),
       plot=err_breakdown_mare_net,
       height=pheight,
       width=pwidth)

err_breakdown_mare_net
```

Sibling MARE

```{r}
#err_breakdown_mare_sib <- err_breakdown_plot('sib_mare', 
err_breakdown_mare_sib <- err_breakdown_plot('mare_Sibling', 
                                             'Sibling\nMARE',
                                             'asdr')

#saveRDS(err_breakdown_mare_sib, 
#        file.path(comp_out_dir, "err_breakdown_mare_sib.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_mare_sib.pdf"),
       plot=err_breakdown_mare_sib,
       height=pheight,
       width=pwidth)

err_breakdown_mare_sib
```

### RMSE


Network RMSE

```{r}
#err_breakdown_rmse_net <- err_breakdown_plot('net_rmse', 
err_breakdown_rmse_net <- err_breakdown_plot('rmse_Network', 
                                             'Network\nRMSE',
                                             'asdr')

#saveRDS(err_breakdown_rmse_net, 
#        file.path(comp_out_dir, "err_breakdown_rmse_net.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_rmse_net.pdf"),
       plot=err_breakdown_rmse_net,
       height=pheight,
       width=pwidth)

err_breakdown_rmse_net
```

Sibling RMSE

```{r}
#err_breakdown_rmse_sib <- err_breakdown_plot('sib_rmse', 
err_breakdown_rmse_sib <- err_breakdown_plot('rmse_Sibling', 
                                             'Sibling\nRMSE',
                                             'asdr')

#saveRDS(err_breakdown_rmse_sib, 
#        file.path(comp_out_dir, "err_breakdown_rmse_sib.rds"))
ggsave(filename=file.path(comp_out_dir, "err_breakdown_rmse_sib.pdf"),
       plot=err_breakdown_rmse_sib,
       height=pheight,
       width=pwidth)

err_breakdown_rmse_sib
```


```{r}
toc()
```




